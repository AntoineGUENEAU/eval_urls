# Formation Django

(2020) Formation par Samuel Dauzon ©

## Présentation de Django

Django est un framework Python WEB complet dont le slogan est "Le framework web pour les perfectionnistes sous pression". C'est un framework très complet qui propose de nombreux outils dont le but est de permettre un développement rapide de sites WEB.
Le framework a été créé en 2003 pour un journal local de la ville Américaine de Lawrence au Kansas. Le but du framework était de permettre la création de site WEB complets rapidement. En 2005, le journal décide de publier le framework sous la licence libre BSD. Par la suite, en 2008, la fondation Django Software se crée et se charge de la gestion de framework.
Aujourd'hui, Django est utilisé sur certains sites à fort trafic :

- Instagram
- Pintereset
- Disqus
- Bitbucket
- Mozilla
- NASA

Selon l'enquête de Stackoverflow de 2020 (https://insights.stackoverflow.com/survey/2020#most-popular-technologies), Django serait utilisé par 14.2% (13% en 2019) des répondants ce qui en fait le 4ème framework back-end le plus utilisé.
Basé sur Python, Django bénéficie de la popularité du langage en constante progression. Ceux qui connaissent Python sont au courant que deux versions majeures du langage existent : la version 2 (bloqué à la 2.7 depuis 2010) et la version 3 qui évolue. L'équipe de développement de Python avait choisi de procéder à une refonte du langage en procédant à un grand ménage des fonctions redondantes. Cette refonte casse la rétrocompatibilité du langage et amène en 2007 à la première version de Python 3 en bêta.
Cette refonte conduit à la vie de deux branches du langage pendant plusieurs années et à une division de la communauté, certains souhaitant rester à la version 2 et d'autres affichant leur soutien à la nouvelle version. Pendant de nombreuses années, la version 3 a été mise de côté sur de nouveaux projets, car les bibliothèques n'étaient pas portées sur Python 3. Au fur et à mesure des années, le portage des bibliothèques et les fonctionnalités apportées à Python 3 ont eu raison de la popularité de Python 3 à tel point que le support de Python 2 devrait s'arrêter en 2020.
Ce qu'il faut retenir de cette explication, c'est que tout nouveau projet en Python doit se faire en Python 3. Il n'y a plus aucune bonne raison de rester en Python 2.

## Un framework MVT

En WEB il est très fréquent d'utiliser un framework MVC (Modèle-Vue-Contrôleur). Python n'est pas un framework MVC mais un framework MVT (Model-View-Template). La différence entre MVC et MVT est très faible. Dans les deux paradigmes, le model représente la même chose : une entité métier avec des attributs et souvent reliée à une base de données (par un ORM ou un Active Record).
La différence se fait au niveau du contrôleur et la vue.
En MVC le contrôleur a la responsabilité d'effectuer des traitements métiers sur les données à afficher à l'utilisateur final par la vue. Dans le cas d'une API seul le contrôleur est appelé, la vue n'est pas appelée.
En MVT le point de vue est plus simillaire à celui d'un client d'API. La vue est chargée d'effectuer des traitements métiers (comme en MVC) et d'envoyer les données, soit à un client d'API soit à un template dont le but est uniquement d'afficher les données selon une organisation définie (en HTML). Ce paradigme part donc du principe qu'un client d'API accède à une vue mais qu'un utilisateur souhaite consulter une vue mise en forme par un template.
La différence entre les deux est infime. Aucune méthode n'est meilleure que l'autre. Le MVT n'est ni plus ni moins qu'une philosophie qui diffère un peu du MVC mais dont les répercussions techniques sont très marginales.
Pour éviter de la confusion, ce document utilisera les termes view(s), template(s) et model(s) pour éviter de confondre view et vue (et aussi une bonne habitude à prendre pour les recherches Google).

## Présentation du projet d'exemple

Ce cours va s'articuler autour d'un projet d'exemple simple.
Nous sommes une agence WEB spécialisée dans le développement de solution sur-mesure.
Une entreprise éditrice d'un logiciel libre populaire souhaite facturer du support sur leur solution.
Pour cela, ils ont besoin d'une interface où des agents répondent aux demandes des clients. Ce projet remplacera leur actuel call-center.
Les clients ne sont pas connus et créent leur compte sur le site.
Pour contacter le support, les clients devront acheter des crédits.
Pour des raisons budgétaires, l'entreprise ne souhaite pas implémenter pour l'instant de paiement en ligne. L'attribution de crédit se fera donc manuellement après réception du paiement par le client.
Des agents de l'entreprise éditrice seront chargés de répondre aux demandes de support.
Après une prise du contact du client, l'agent définit le cout en crédit du support que le client doit accepter avant de continuer. Le cout peut-être revu si besoin.
Un seul niveau de support est prévu pour l'instant.
Le débit de crédit n'a lieu que lorsque le client a coché "Prise en charge terminée"
Une mission de support non terminé et dont le dernier message a plus de 96h est considérée comme clôturée.

## Installer Python et l'environnement virtuel

Sous Windows les commandes Python s'exécutent avec la commande py.
Sous les systèmes UNIX, il faut utiliser la commande python3.

Pour créer un environnement virtuel, il faut utiliser la commande suivante :

```
python3 -m venv venv_project
```

Un environnement virtuel est un environnement python qui serra séparé de l'environnement standard du système d'exploitation. Cet environnement permettra d'utiliser un système propre à chaque projet.
Cela permet d'avoir pour chaque projet un environnement séparé avec des versions de bibliothèques séparées. Par exemple, cela permet de maintenir 2 projets, un sous Django 1.11, un sous Django 2.1 sans avoir à désinstaller et réinstaller Django à chaque fois.
Utiliser un environnement virtuel nécessite de l'activer. Pour cela, il faut utiliser la commande suivante :

```
source venv_project/bin/activate
```

Une fois l'environnement activé, la commande python s'exécute dans l'environnement virtuel (et il est possible d'utiliser la commande python sous Windows). Le gestionnaire de paquet Python pip gèrera donc les dépôts dans le cadre de l'environnement.
Pour installer Django dans l'environnement, il faut donc utiliser la commande suivante :

```
pip install Django
```

Pour vérifier l'installation, il est possible d'utiliser les commandes suivantes :

```
python
import django
exit()
```

Pour afficher la liste des bibliothèques installées, il faut utiliser la commande suivante :

```
pip freeze
```

Cette commande est également utilisée pour créer le fichier `requirements.txt` (équivalent de `package.json` pour npm).
Attention : Dans toute la suite de ce projet, les commandes seront à exécuter avec l'environnement virtuel activé. Il est important de réactiver l'environnement virtuel à chaque développement sur le projet.


## Création du projet Django

Avant de créer un projet Django, il est conseillé de créer un dossier propre au projet et d'y créer l'environnement virtuel :

```
mkdir intranet_phonecenter
cd intranet_phonecenter
python3 -m venv venv_intranet_phonecenter
source venv_intranet_phonecenter/bin/activate
pip install Django==3.1.3
```

Une fois Django installé, il est possible d'utiliser la commande `django-admin` pour créer un nouveau projet django :

```
django-admin startproject intranet_phonecenter
```

Cette commande créer le dossier intranet_phonecenter qui va contenir l'ensemble du projet Django. Dans ce dossier, il y a plusieurs éléments :

Le fichier manage.py est le fichier qui va permettre d'utiliser les lignes de commandes propres au framework Django.

Une fois le projet crée, Django permet déjà de lancer le serveur de développement. Pour cela, il faut utiliser la commande suivante :

```
cd intranet_phonecenter
python manage.py runserver
```

Cette commande démarre un serveur de développement sur l'adresse localhost au port 8000.

Il est également possible de définir un port d'écoute différent en ajoutant à la commande l'ipet le port d'écoute :

```
python manage.py runserver 127.0.0.1:8080
```

Il est possible de définir l'adresse IP `0.0.0.0` pour ouvrir le serveur au réseau local (ou public). Ainsi, une machine sur le même réseau local pourra utiliser l'adresse IP du serveur pour consulter le site.

Attention : ce serveur de développement est conçu pour le développement. Il n'est pas assez sécurisé ni assez rapide pour une mise en production.

Pour commiter le début du projet il faut tout d'abord ajouter un fichier .gitignore adapté au projet. Pour cela, il est possible d'en trouver un à l'adresse suivante : `https://github.com/github/gitignore/blob/master/Python.gitignore`.

Ensuite il faut utiliser les commandes suivantes :

```
git init
git add --all
git commit -m "BigBang : creation of projet"
git tag bigbang
```

## Ajout d'applications Django

Un projet Django est organisé en applications. Attention, ici rien à voir avec une application mobile, il s'agit d'organiser sémantiquement son projet.
Un projet Django conséquent est donc idéalement composé de plusieurs applications Django. Ces applications vont pouvoir s'interfacer entre elles.
Dans le cas des applications les plus génériques, il est possible de les mutualiser entre plusieurs projets en utilisant pip ou des dépôts intégrés (submodules), voir `https://stackoverflow.com/questions/13179778/maintaining-3rd-party-django-apps-as-git-submodules`.

Par exemple, dans le cas d'un forum il est possible d'imaginer les applications suivantes (avec leurs responsabilités) :
- **users** : Partie utilisateurs : connexion, inscription, mot de passe oublié, etc.
- **messages** : Partie messagerie instantanée : échange de messages entre users,
- **topics** : Partie sujets de forum : Liste des sujets, affichage du sujet, participation au sujet

Pour notre exemple de système de support d'un call-center, il est possible d'imaginer découper le projet en 3 applications :
- **users** : Partie utilisateur : connexion, inscription, mot de passe oublié, etc.
- **customer** : Partie cliente : Ajout client, définition contrat, etc.
- **credits** : Partie crédits : Ajout de crédits à un client, etc.
- **calls** : Partie appels téléphoniques : historique des appels, renseignement d'un appel, etc.
- **supports** : Partie assistance écrite : commencer une mission d'assistance, interface agent et user, historique, etc.

Pour créer ces applications dans notre projet, il faut utiliser les commandes suivantes :

```
python manage.py startapp users
python manage.py startapp customer
python manage.py startapp credits
python manage.py startapp calls
python manage.py startapp supports
```

Ces commandes permettent de créer les dossiers correspondants aux applications dans le projet. Dans chacun de ces dossiers se trouvent des fichiers créés automatiquement par Django :

- **admin.py** : Ce fichier permet de paramétrer l'interface autogénérée d'administration de l'application.
- **apps.py** : Ce fichier permet de gérer la configuration d'une application.
- **migrations** : Ce dossier contient les migrations de base de données de l'application (le dossier est vierge au début).
- **models.py** : Ce fichier contient les models de l'application.
- **tests.py** : Ce fichier contient les tests automatisés de l'application
- **views.py** : Ce fichier contient les views de l'application.

Git :

```
git add --all
git commit -m "Applications : creation"
git tag app_creation
```


## Intégration des applications Django dans le projet

Pour intégrer les applications nouvellement créées aux projets, il va falloir les définir dans la configuration du projet. Pour cela il faut éditer le fichier `intranet_phonecenter/settings.py`. Ce fichier contient la configuration du projet.
La variable `INSTALLED_APPS` contient une liste des applications Django intégrées au projet. De nombreuses applications internes à Django sont déjà ajoutées, il faut ajouter les applications créées à la fin de la liste. Il faut respecter l'ordre de dépendance des applications, les applications dépendantes des autres déclarées après :

```
INSTALLED_APPS = [
    # Apps déjà pré-installées
    # ....
    'users',
    'customer',
    'credits',
    'calls',
    'supports',
]
```

Il est également nécessaire de configurer les applications dont les views et les URLS seront utilisées. Pour cela, il faut ajouter les fichiers urls.py de chaque application en définissant la variable `app_name` correspondante au nom de l'application après les imports. Par exemple, pour l'application `users`, il faut créer le fichier `users/urls.py` avec le contenu suivant :

```
# coding: UTF-8
from django.urls import path

app_name = 'users'
urlpatterns = [

]
```

Il faut faire de même pour chaque applications du projet.
Il faut ensuite modifier le fichier `intranet_phonecenter/urls.py` afin d'importer les applications et de définir les modules d'URL d'application :

```
from django.urls import path, include

import users
import customer
import credits
import calls
import supports

urlpatterns = [
    path(r'users/', include('users.urls', namespace='users')),
    path(r'customer/', include('customer.urls', namespace='customer')),
    path(r'credits/', include('credits.urls', namespace='credits')),
    path(r'calls/', include('calls.urls', namespace='calls')),
    path(r'supports/', include('supports.urls', namespace='supports')),
]
```

La variable `urlpatterns` contient les différents patrons d'URL. Le fichier `intranet_phonecenter/urls.py` contient les URLs globales du site et gère les appels HTTP faits au projet. Il dispatch ensuite les appels aux différents fichier (appelés ici modules) urls des applications. Ainsi, une requête HTTP portant sur l'URL `http://host/users/my_account` va être d'abord gérée par le module urls du projet, le module va détection que la requête commence par `users/` et va donc appelé le module `urls` de l'application `users`.

Git :

```
git add --all
git commit -m "Applications : project integration"
git tag app_project_integration
```



## Hello World ! Liaison urls - views

Cette partie va permettre d'omettre totalement la partie liée aux données dynamiques (base de données, models, migrations, formulaires, etc.) pour se concentrer sur le chemin que prendre une requête HTTP jusqu'à l'affichage d'un simple texte.
Le but de cette partie est de créer la première view sans aucun template.
Il faut tout d'abord créer la view dans l'application user (choisie arbitrairement). Pour cela, il faut éditer le fichier `users/views.py` et ajouter le code suivant:

```
# Import
from django.http import HttpResponse

# View
def hello(request):
    return HttpResponse("Hello World!")
```

La view est une fonction qui prend en paramètre la requête HTTP (paramètre request). La valeur de retour de la view est ce qui est retourné à l'utilisateur. Cela peut-être une page générée à partir d'un template, du JSON, un fichier ou encore du texte comme ici.
Pour que la view soit appelée en HTTP, il faut qu'elle soit liée à une URL. Pour cela, il faut éditer le fichier `users/urls.py` en ajoutant les lignes suivantes :

```
# Import du module views de l'application users
from users import views

urlpatterns = [
    path('hello/', views.hello, name="hello"),
]
```

La fonction `path()` permets de définir une URL dans la liste des URLs de l'application :

1. Le premier argument définit le patron de l'URL.
2. Le deuxième argument est la view à appeler.
3. Le troisième argument (facultatif) est le nom de l'URL. Il peut-être utile pour la génération d'URL.

Cet exemple volontairement simpliste ne convient absolument pas pour un site en production. Pour des appels API, il est plus indiqué de renvoyer du JSON et pour afficher une page il est préférable d'utiliser le système de templates.

Il suffit d'appeller la page http://localhost:8000/users/hello pour afficher le "Hello World!". Dans cette URL, le chemin `users` est défini dans le fichier `/intranet_phonecenter/urls.py` et le fin de l'URL `/hello` est définie dans le fichier `users/urls.py`.

Git :

```
git add --all
git commit -m "Hello World : simple version"
git tag hello_world_simple
```

## Configuration des templates

Le système de template de Django offre certaines fonctionnalités. Cependant, avant de coder le moindre template, il est nécessaire de configurer la façon avec laquelle Django va chercher les templates à afficher. Il faut donc savoir comment sera organisé le stockage des templates. Il existe deux façons populaires de stocker les templates :

1. Dans chaque application Django
2. Dans le dossier du projet (ici : le dossier intranet_phonecenter)

Chaque méthode a ses avantages et ses inconvénients.
La première méthode permet une très bonne réutilisabilité des applications et notamment des templates. Cette méthode impose cependant de gérer des chemins de templates plus longs à manipuler comme : `users/templates/users/connexion.html`. Cette méthode impose également à Django d'aller chercher le bon template dans la bonne application. Cette méthode est utile notamment lorsqu'on réutilise des applications Django mutualisées.
La deuxième méthode permet de centraliser tous les templates et de ne définir dans la configuration de Django qu'un seul chemin où chercher les templates. L'inconvénient principal étant la difficulté de réutilisation des templates liés aux applications Django. Dans un projet spécifique où aucune application Django n'est réutilisée (et où aucune n'est amené à l'être), cette méthode permet de simplifier la gestion des templates et des héritages.

Dans cet exemple, pour maximiser l'utilisation des bonnes pratiques nous utiliserons la deuxième méthode. Une fois la méthode choisie, il faut indiquer à Django où il devra aller chercher les templates. Pour cela, il faut modifier le fichier `intranet_phonecenter/settings.py` :

```
# Dans les imports
import os

# A la place de la configuration des templates actuels
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'intranet_phonecenter', 'templates'),
            # os.path.join(BASE_DIR, 'users', 'templates'), # No needed thanks to APP_DIRS
            # os.path.join(BASE_DIR, 'customer', 'templates'), # No needed thanks to APP_DIRS
            # os.path.join(BASE_DIR, 'credits', 'templates'), # No needed thanks to APP_DIRS
            # os.path.join(BASE_DIR, 'calls', 'templates'), # No needed thanks to APP_DIRS
            # os.path.join(BASE_DIR, 'supports', 'templates'), # No needed thanks to APP_DIRS
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

Dans ce code, la liste `DIRS` permet de définir les chemins dans lesquels Django ira chercher les templates. La valeur `APP_DIRS` permet d'indiquer à Django de chercher des templates dans les dossiers templates des applications installées. Cela permet d'éviter de définir les lignes correspondant aux applications (lignes commentées). Cela permet d'écrire encore moins de code lors de la création d'une nouvelle application.
Une fois le projet configuré, il faut créer les chemins des templates. Avant de créer ces chemins, il est important de savoir de quelle façon ils seront appelés. Une fonction permettra d'aller chercher un template en fonction de son chemin qui sera sous la forme `app/template.html`. À partir de ce chemin, Django vérifiera dans les chemins définis s’il en a un qui correspond. Il faut donc créer les dossiers manquants des chemins suivants :

```
intranet_phonecenter/templates
users/templates/users
customer/templates/customer
credits/templates/credits
calls/templates/calls
supports/templates/supports
```

Pour que chacun de ces chemins soit versionné malgré leur absence de fichier, il ne faut pas oublier d'y créer un fichier `.gitkeep`.

Git :

```
git add --all
git commit -m "Template : Settings paths"
git tag template_settings_path
```



## Héritage de template

Django est fournit avec un service de templates évolué offrant des fonctionnaliés intéressantes. Par exemple, le système intègre un système d'héritage de templates très utile.
Dans le contexte, l'idée est de créer 3 niveaux de template.

Template de base dans le projet

Un template base.html stocké dans le dossier intranet_phonecenter/templates. Ce template sera le template de base de tout le projet. C'est ce template qui va architecturer les différentes pages du site. Les autres templates du projet (sauf exceptions) hériteront de ce template.
Un code vaut mille mots, pour l'explication des syntaxes commençons par visualiser le fichier `intranet_phonecenter/templates/base.html` :

```
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}Intranet-Phonecenter{% endblock title %}</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>

    {% load static %}
    <script src="{% static 'js/base.js' %}"></script>
    <link href="{% static 'css/base.css' %}" rel="stylesheet">

    {% block head_end %}{% endblock head_end %}
  </head>

  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="#">IntranetPhonecenter</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarsExampleDefault">


      </div>
    </nav>

    {% block body_header %}{% endblock body_header %}
    <main role="main" class="container" style="padding-top:60px;">

      <div class="starter-template">
        {% block content %}{% endblock content %}
      </div>

    </main>

    {% block body_footer %}{% endblock body_footer %}

  </body>
</html>
```

Ce fichier est une structure standard de site WEB Bootstrap / jQuery. Il représente la structure dont bénéficiera chaque page du projet.
Dans ce template, des blocs sont définis par la syntaxe suivante :

```
{% block title %}Intranet-Phonecenter : {% endblock title %}
```

Cette syntaxe signifie que cet endroit est une partie du template qui peut être surchargée par les templates enfants. Dans ce cas-là, le template se nomme title et possède comme valeur par défaut Intranet-Phonecenter. Ce bloc a vocation a être modifié sur chaque page pour définir le titre de la page. Ce bloc est d'autant plus important dans un site dont le SEO (référencement naturel) est crucial.
Ainsi, dans un template enfant, la ligne suivante définie le titre :

```
{% block title %}Intranet-Phonecenter : Connexion {% endblock title %}
```

Il est d'ailleurs possible de récupérer la valeur parente et de la surcharger en ajoutant le terme `Connexion` ainsi :

```
{% block title %} {{ block.super }} Connexion {% endblock title %}
```

La ligne suivante permet de charger le module gérant les fichiers statiques afin de les importer :

```
{% load staticfiles %}
```

C'est cette ligne qui permet de générer les URLs des lignes suivantes pour importer les fichiers CSS/JS standard du projet :

```
<script src="{% static 'js/base.js' %}"></script>
<link href="{% static 'css/base.css' %}" rel="stylesheet">
```

Le template intègre également :

- Un menu de navigation
- Un bloc `body_header`
- Un bloc `content` qui sera le bloc qui, surchargé, contiendra le contenu spécifique des différentes pages du projet.
- Un bloc `body_footer`

Template de base dans l'app

Ajouter dans chaque application un template duquel les autres hériteront est une méthode offrant plusieurs avantages :

- Une meilleure portabilité de l'application, car la personnalisation de ce template unique peut permet d'intégrer tous les templates de l'application dans un projet.
- La possibilité de modifier la charte graphique d'une application. Une application d'administration interne du site (différent du module d'admin Django) pourra par exemple arborer des couleurs différentes du reste du projet.
- La possibilité d'ajouter des fonctionnalités JS propres à l'application.

Le projet commençant tout juste, nous créerons uniquement des templates intermédiaires sans personnalisation métier. Créer ces templates (inutiles pour l'instant) permet, lorsque le besoin se présentera d'ajouter les comportements nécessaires au projet.

Dans les chemins `{app_name}/templates/{app_name}` il faut créer le fichier base.html avec le contenu suivant :

```
{% extends "base.html" %}
```

Cette unique ligne effectue l'héritage du template en héritant du template `intranet_phonecenter/base.html`. Il serait possible de vouloir surcharger le titre par défaut de chaque page de l'application users. Pour cela, il faudrait définir le contenu suivant dans le fichier `users/templtes/users/base.html` :

```
{% extends "base.html" %}

{% block title %}Utilisateurs{% endblock title %}
```

L'affichage du template users/templtes/users/base.html afficherait dans le navigateur la structure définie dans le template `intranet_phonecenter/templates/base.html` avec comme seule différence le titre `Utilisateurs`.

À présent, la structure des templates est correctement définie. Le développement des templates va pouvoir démarrer.

Git :

```
git add --all
git commit -m "Template : base projet & app definition"
git tag template_base_project_app
```




## Hello World en template - liaison views - templates

Avec tout le système de template mis en place, il est possible de faire passer le hello world au niveau supérieur. Pour cela, il faut modifier le fichier `users/views.py` ainsi :

```
# Import
from django.http import HttpResponse
from django.shortcuts import render

# View
def hello_old(request):
    return HttpResponse("Hello World!")

def hello(request):
    return render(
        request,
        'users/hello.html',
        {
            'message': "Hello World!",
        }
    )
```


Les deux views se comparent aisément. La première, codée précédemment, renvoie un objet de type `HttpResponse` qui renvoie uniquement du texte brut à l'utilisateur. La deuxième views renvoie le retour de la fonction `render()`. Cette fonction prend en paramètre l'objet request, le template ainsi qu'un contexte de variables à envoyer au temmplate.

Le Hello world n'est pas encore fonctionnel, car il manque le template. Pour corriger cela, il faut créer le fichier `users/template/users/hello.html` avec le contenu suivant :

```
{% extends "users/base.html" %}

{% block content %}
    {{ message }}
{% endblock content %}
```

Ce template hérite du template `users/base.html` qui hérite lui-même de `intranet_phonecenter/base.html`. Il surcharge ensuite le bloc `content` et y affiche le message grâce à la ligne :

```
{{ message }}
```

Cette syntaxe est utilisée pour afficher de nombreux types de variables : `string, int, float, etc`.
La page est visualisable via l'URL `http://localhost:8000/users/hello/`.
L'affichage est baclé mais les informations sont bien là dans le DOM défini en respectant les héritages.

Git :

```
git add --all
git commit -m "HelloWorld : with template"
git tag hello_world_template
```


## Configuration du projet

Avant de se lancer dans un projet, il est important de savoir comment fonctionne la configuration d'un projet Django. Tout d'abord, il est conseillé de ne pas versionner la configuration d'un projet, quel que soit le framework (sauf exception) car la configuration de production est amenée à stocker différents éléments sensibles :

- Identifiants de base de données
- Identifiants d'API externe/interne
- Clé de sécurité pour de chiffrement ou du hachage
- email
- etc.

On voit de trop nombreux cas de fuite de ces données sur Github aujourd'hui. Il faut donc faire les choses correctement dès le début du projet. Il existe différentes façons de gérer les données sensibles : fichiers de configuration locaux, variables d'environnements, etc. Nous choisirons ici d'utiliser différents fichiers locaux.
Les éléments de configuration d'un projet Django sont stockés dans le dossier `project/settings.py` (ici `intranet_phonecenter/settings.py`). Par défaut, lors de la création du projet, Django préremplit ce fichier avec des valeurs par défaut. Nous allons renommer ce fichier en `local_settings.py`:

```
mv intranet_phonecenter/settings.py intranet_phonecenter/local_settings.py
```

Pour que ce fichier ne soit soit pas versionné il faut l'ajouter au fichier .gitignore. Par chance, le fichier `.gitignore` que nous avons récupéré sur Github contient déjà la ligne suivante :

```
local_settings.py
```

Pour que Django puisse charger ce nouveau fichier de configuration il faut recréer le fichier intranet_phonecenter/settings.py avec le contenu suivant :

```
try:
    from .local_settings import *
except ImportError as e:
    print("No local settings module found")
```


Tout d'abord, la gestion d'exception définie dans ce fichier permet d'afficher une erreur lorsque l'import échoue.
Lorsqu'un import commence par un point `.`, cela signifie que l'import a lieu dans le module actuel (c'est-à-dire dans le dossier du fichier). La ligne :
```
from .local_settings import *
```

Signifie donc qu'il faut importer tous les éléments (variables, classes, fonctions, etc.) du fichier local_settings.py du dossier actuel dans le fichier actuel.
Lors de la mise en production, le fichier local_settings.py à envoyer au serveur est différent de celui existant dans le projet en cours de développement.

En allant consulter le fichier `intranet_phonecenter/local_settings.py` il est possible de se rendre compte des éléments principaux configurables :

- L'option `DEBUG` permet d'activer l'affichage d'erreur du site.
- L'option `ALLOWED_HOSTS` permet de définir les hostnames autorisés du site.
- La valeur `SECRET_KEY` est utilisée pour les fonctions cryptographiques du site et les opérations de hachage.
- L'option `TEMPLATES`  que nous avons utilisée et qui permet de configurer le système de templates.
- L'option `DATABASES` permet de configurer les bases de données du projet.

Pour gérer différentes configurations, il est également possible d'utiliser l'argument --settings du fichier manage.py :

```
python manage.py runserver --settings=intranet_phonecenter.local_settings
```

Pendant toute la durée de développement, et pour éviter les mauvaises surprises au déploiement d'un projet, il est conseillé de travailler sur le même environnement que celui de production.
Pour des raisons de simplicité, nous choisirons ici de travailler sur notre système d'exploitation et avec le système de base de données SQLite défini par défaut dans la configuration du projet.

Git :

```
git add --all
git commit -m "Settings : create local_settings"
git tag settings_create_local
```


## Les models Django

Cette sous-partie est volontairement déconnectée du projet de fond pour commencer à parler des models avec des exemples simples. En effet, les premiers models du projet ne vont pas être les plus simple car ils vont hériter de models abstraits.

Tout d'abord, il convient d'expliquer ce qu'est un model Django. Les models sont des objets liés à la base de données. Ce sont des éléments très communs dans les frameworks WEB disposant d'un ORM évolué (totalement différent d'un active Record bête et méchant mais simple d'usage).

Généralement un model Django va se concrétiser par une table en base de données. Il va également pouvoir accueillir des comportements métiers, car il ne sert pas uniquement à la liaison Django / base de données.

Il est possible d'imaginer par exemple d'imaginer un model simple représentant un article de Wikipédia :

```
from django.db import models

class Article(models.Model):
    title = models.TextField(
        verbose_name = "Titre",
        max_length = 100,
        unique = True,
        )
    content = models.TextField(
        verbose_name = "Contenu",
        )
    created = models.DateTimeField(
        auto_now_add = True,
        verbose_name="Date de création",
        db_index=True,
        )
    protected = models.BooleanField(
        verbose_name = "Article protégé",
        help_text = "L'article ne peut être modifié que par des administrateurs",
        default = False,
        )
    popularity = models.IntegerField(
        verbose_name = "Niveau de popularité",
        default = 0,
        db_index = True,
    )

    class Meta:
        verbose_name = "Articles"
        ordering = ("created", )
```

Ce model est un exemple simpliste proposant un certain nombre de champs. Tout d'abord, dans un model il faut définir une classe héritant de la classe `models.Model`. Il convient ensuite d'y définir les champs du model à définir. Ici le model contient 5 champs :

- `title` : de type texte, avec la contrainte unique en base de données
- `content` : de type texte
- `created` : de type Datetime indexé en base de données
- `protected` : de type booléen défini à false par défaut en base de données
- `popularity` : de type nombre entier défini à 0 comme valeur par défaut

Django crée automatiquement la clé primaire de la table. La création de ce model ne suffit pas à créer la table ne base de données. Pour cela, il va falloir utiliser le système de migrations.
Une migration est un fichier regroupant un ensemble de modifications de base de données. Ce fichier sera généré automatiquement par le système de migration de Django. L'exécution des modifications de bases de données sera aussi effectuée par Django.
Pour créer le fichier de migration, il faut utiliser la commande :

```
python manage.py makemigrations
```

Si l'application ne possède pas encore de dossier migrations, il est nécessaire d'ajouter à la commande le nom de l'application. Les fichiers de migration créés par la commande sont voués à être versionnés.
Ensuite, pour exécuter les migrations, il faut lancer la commande :

```
python manage.py migrate
```

Cette commande va vérifier les migrations contenues dans le projet, les migrations déjà effectuées, et va exécuter celles qui ne l'ont pas été.
Il est d'ailleurs possible d'afficher la liste des migrations en utilisant la commande :

```
python manage.py showmigrations
```


## Fonctionnalité : Mise en place des utilisateurs

La première fonctionnalité du site va être la mise en place des utilisateurs. Django propose déjà un système permettant de gérer des utilisateurs. La façon la plus efficace de bénéficier de ces outils tout en gardant la main est d'utiliser un model abstrait fourni par Django.

Dans la partie précédente, nous avons vu que la classe `Article` héritait de la classe `models.Model`. Il est possible de rajouter autant de niveaux hiérarchiques que nécessaire. Par exemple, j'aime bien avoir un certain nombre de données sur presque toutes mes tables qui sont les dates de création et de dernière modification. Pour cela, il va falloir commencer par créer ce model dans le fichier `users/models.py` :

```
from django.db import models

class BaseModel(models.Model):
    created       = models.DateTimeField(auto_now_add = True, verbose_name="Date de création")
    modified      = models.DateTimeField(auto_now = True, verbose_name="Date de modification")

    class Meta:
        abstract = True
        ordering = ("-created", )
```

Ce model est un model abstrait, c'est-à-dire que ce model ne va pas se concrétiser par une table en base de données, il va servir de base pour d'autres models. Dans ce modèle, deux champs de type `Datetime` sont définis et vont servir à connaitre la date d'ajout et de modification de chaque enregistrement. La class `Meta` interne à la classe permet d'ajouter des comportements au model. Ici la ligne `abstract = True` définis la nature abstraite du model. La ligne `ordering = ("-created", )` définie que le tri par défaut qui sera effectué sur les listes d'enregistrements seront fait du plus récent au plus ancien.
Le modèle qui va permettre de gérer les utilisateurs va hériter de notre classe abstraite, mais également d'un autre (l'héritage multiple existe en Python), la classe `AbstractUser` fournit par Django qui offre des fonctionnalités au sein du framework. Par défaut, le model `AbstractUser` fournit :

- Un champ `username`
- Un champ `email`
- Un certain nombre de méthodes utiles à la gestion des utilisateurs

Le model gérant les utilisateurs de sites va comprendre tous les utilisateurs qui peuvent se connecter au site WEB. La première version du site sera simpliste, les 2 types d'utilisateurs (clients et les membres de l'équipe) seront différenciés par un rôle et des liaisons avec des models spécifiques pour chaque rôle (voir ce lien pour les bonnes pratiques de gestion utilisateur: https://simpleisbetterthancomplex.com/tutorial/2018/01/18/how-to-implement-multiple-user-types-with-django.html)

Voici le model UserProfile :

```
from django.contrib.auth.models import AbstractUser

class UserProfile(AbstractUser, BaseModel):

    USER_TYPE_CHOICES = (
        (1, 'teammember'),
        (2, 'client'),
        )

    user_type = models.PositiveSmallIntegerField(
        choices=USER_TYPE_CHOICES,
        default=None,
        blank=True,
        null=True,
        )

    display_name = models.TextField(
        verbose_name="Nom d'affichage",
        default=None,
        blank=True,
        null=True,
        )

    def __str__(self):
        if self.display_name :
            return self.display_name
        else:
            return self.username

    class Meta:
        verbose_name = "Utilisateur"
        verbose_name_plural = "Utilisateurs"
        ordering = ("created", )
```


Ce model comprend un certain nombre d'éléments.
La ligne `class UserProfile(AbstractUser, BaseModel):` permet de définir le model `UserProfile` héritant des models `AbstractUser` et `BaseModel`. Cela signifie que le modèle va hériter des comportements des deux classes.
Le code définit dans la variable `USER_TYPE_CHOICES` les types de choix possibles pour le type d'utilisateurs. Chaque élément de cette liste de types contient un tuple associant un identifiant et un type d'utilisateurs.
Ensuite, le champ user_type est défini en champ numérique entier qui peut prendre les valeurs contenues dans la variable `USER_TYPE_CHOICES`. Par défaut, le champ prend la valeur None.
Le champ `display_name` est défini et est chargé de stocker le nom d'affichage de l'utilisateur.
La méthode `__str__()` est une méthode spéciale pour les modèles. C'est une méthode qui doit retourner une valeur texte représentative d'un enregistrement du modèle. Ici la méthode retourne le nom d'affichage s'il est défini, si ce n'est pas le cas, la méthode retourne le nom d'utilisateur (champ username hérité du model `AbstractUser`).

```
class TeamMember(BaseModel):

    teammember = models.OneToOneField(
        UserProfile,
        on_delete=models.CASCADE,
        primary_key=True,
        )

    support_level = models.PositiveSmallIntegerField(
        default=1,
        )


class Customer(BaseModel):

    customer = models.OneToOneField(
        UserProfile,
        on_delete=models.CASCADE,
        primary_key=True,
        )

    credits = models.IntegerField(
        default=0,
        )

```

Ces deux nouveaux models seront liés au model UserProfile par une relation `OneToOneField`. Cela signifie qu'un utilisateur ne pourra avoir qu'un seul rôle spécifique. Les modèles liés contiennent les propriétés et méthodes spécifiques liés au type d'utilisateur. Ainsi, le membre d'équipe se verra attribuer un niveau de support et un client possèdera un certain nombre de crédits (monnaie interne du site).

Pour connecter le model UserProfile aux mécanismes d'utilisateurs Django, il faut indiquer dans la configuration Django ce model. Pour cela, il faut modifier le fichier `intranet_phonecenter/settings.py` en ajoutant la ligne suivante :

```
AUTH_USER_MODEL = "users.UserProfile"
```

Pour que la création des models soit appliquée à la base de données, il faut tout d'abord générer la migration en utilisant la commande suivante :

```
python manage.py makemigrations
```

Pour appliquer la migration à la base de données, et pour l'occasion créer la base SQLite, il faut utiliser la commande suivante :

```
python manage.py migrate
```

Il est généralement courant après la mise en place des utilisateurs de créer le premier utilisateur administrateur. Pour cela, il faut utiliser la commande suivante et suivre les différentes étapes :

```
python manage.py createsuperuser
```
En local vous pouvez vous permettre de définir un superuser admin / admin. A ne jamais faire en production (même lors de la mise en place du projet)

Git :

```
git add --all
git commit -m "Users : create UserProfile model"
git tag users_user_profile_model
```

## Le module d'administration Django

Le module d'administration est un des avantages de Django car il permet d'avoir une interface auto générée pour administrer les données du projet.
Ce module d'administration est paramétrable en fonction des besoins du projet. Dans le cas du projet d'exemple, il est possible d'ajouter la gestion des utilisateurs dans le module d'administration en modifiant le fichier `users/admin.py` :

```
from django.contrib import admin

from .models import UserProfile, TeamMember, Customer

class UserProfileAdmin(admin.ModelAdmin):
    list_display = ('username', 'email', 'user_type', 'display_name', )
    list_filter = ['user_type', ]
    list_editable = ['display_name', ]
    search_fields = ['username', 'email', 'display_name', ]

admin.site.register(UserProfile, UserProfileAdmin)
admin.site.register(TeamMember)
admin.site.register(Customer)
```

Dans cet exemple, la classe UserProfileAdmin permet de définir les besoins spécifiques d'affichage de l'administration. Dans cet exemple, plusieurs propriétés sont définies :
- **list_display** : permet de définir les champs à afficher dans la liste d'affichage des enregistrements.
- **list_filter** : permet de définir des critères de filtre. Django affiche la liste des différentes valeurs dans lesquels filtrer. Il convient donc de l'utiliser sur des champs avec un nombre limité de valeur (les champs booléens étant les plus adaptés).
- **list_editable** : permet de définir les champs modifiables directement à partir de la liste des enregistrements.
- **search_fields** : permet d'ajouter un champ de recherche pour filtrer la liste d'enregistrements. Les champs définis sont ceux dans lesquels Django va effectuer la recherche.
- **readonly_fields** : permet de définir les champs en lecture uniquement et non modifiables par l'administration.

L'interface d'administration auto générée propose aussi de nombreuses autres options de personnalisation expliquées dans la documentation officielle : https://docs.djangoproject.com/fr/2.2/ref/contrib/admin/.

```
admin.site.register(UserProfile, UserProfileAdmin)
```
Cette ligne permet d'ajouter le model UserProfile à l'interface d'administration. Le deuxième argument permet de spécifier les besoins précis définis dans la classe UserProfileAdmin.
```
admin.site.register(TeamMember)
admin.site.register(Customer)
```
Ces deux lignes permettent d'ajouter les models TeamMember et Customer au module d'administration sans aucune option de personnalisation.

Il est possible d'accéder à l'interface d'administration à l'URL suivante : http://localhost:8000/admin après connexion avec l'utilisateur créé.
Il est possible d'attribuer un rôle de membre d'équipe à l'utilisateur administrateur créé.

Lorsqu'un model géré par le module d'administration n'est pas personnalisé avec `list_display` et qu'il n'a pas de méthode `__str__()` définie, l'affichage de la liste des enregistrements est très abstrait.
Pour changer cela, il faut définir la méthode `__str__()` dans les models qui n'en ont pas.
Dans le fichier `users/models.py` il faut ajouter

```
# Au model TeamMember :

def __str__(self):
    return str(self.teammember)

# Au model Customer :

def __str__(self):
    return str(self.customer)
```

Pour rendre accessible le module d'administration Django il faut ajouter l'URL suivante dans le fichier `intranet_phonecenter/urls.py` :

```
# Ajouter aux imports :
from django.contrib import admin

admin.site.enable_nav_sidebar = False

# Ajouter aux URLs :
path('admin/', admin.site.urls),
```

Il faut également ajouter le menu suivant dans le fichier `intranet_phonecenter/templates/base.html` :

```
{% if request.user.is_superuser %}
  <ul class="navbar-nav mr-auto">
    <li class="nav-item active">
      <a class="nav-link" href="{% url 'admin:index' %}">Admin Django</a>
    </li>
  </ul>
{% endif %}
```

## Page d'inscription

La page d'inscription permettra à des utilisateurs de s'inscrire sur le site, sans leur attribuer un rôle automatiquement (l'interface d'administration le permet pour l'instant).
Nous allons créer la page d'inscription en utilisant un formulaire Django. Pour cela, nous allons créer le fichier `users/forms.py` qui va contenir les formulaires de l'application users. Le fichier contiendra le contenu suivant :

```
from django import forms

from .models import UserProfile


class RegisterForm(forms.Form):
username = forms.CharField(
    label = "Nom d'utilisateur",
    max_length=64,
    required=True,
    )
email = forms.EmailField(
    label = "Adresse Email",
    max_length=256,
    required=True,
    )
raw_password = forms.CharField(
    label = "Mot de passe",
    max_length=256,
    required=True,
    help_text = "10 caractères minimum",
    widget=forms.PasswordInput(),
)
raw_password_confirmation = forms.CharField(
    label = "Mot de passe (confirmation)",
    max_length=256,
    required=True,
    widget=forms.PasswordInput(),
    )

def clean(self):
    cleaned_data = super(RegisterForm, self).clean()
    raw_password = cleaned_data.get('raw_password')
    raw_password_confirmation = cleaned_data.get('raw_password_confirmation')
    if len(raw_password) < 10:
        raise forms.ValidationError("Le mot de passe doit faire 10 caractères minimum")
    if raw_password and raw_password_confirmation:
        if raw_password != raw_password_confirmation:
            raise forms.ValidationError("Les mots de passe ne sont pas identiques")
    try:
        UserProfile.objects.get(username=cleaned_data['username'])
    except UserProfile.DoesNotExist:
        pass
    else:
        raise forms.ValidationError("Cet utilisateur existe déjà")

    try:
        UserProfile.objects.get(email=cleaned_data['email'])
    except UserProfile.DoesNotExist:
        pass
    else:
        raise forms.ValidationError("Cet utilisateur existe déjà")

    return cleaned_data
```

Ce fichier permet de définir la classe `RegisterForm` qui hérite de la classe `forms.Form` fournie par Django. Dans cette classe, nous avons défini 4 propriétés `username`,  `email`,  `raw_password`,  `raw_password_confirmation` auquelles on a attribué dans champs de formulaire de type `CharField` et `EmailField`. Ces types vont avoir une influence sur l'affichage du formulaire et sur sa validation.
La documentation de Django sur les formulaires permet d'en apprendre plus sur les formulaires, leurs champs, leur validation, etc. : https://docs.djangoproject.com/fr/2.2/topics/forms/.

```
widget=forms.PasswordInput(),
```
Cette ligne est présente dans la définition des champs `raw_password`, `raw_password_confirmation`. Elle permet de surcharger l'affichage (donc le **widget**) de ces champs sous forme de mots de passe avec des •••• au lieu des caractères.

La méthode `clean()` ici correspond à une surcharge de la méthode d'origine. Il est très important d'utiliser la ligne suivante dans cette surcharge pour bénéficier des validations effectuées par Django :

```
cleaned_data = super(RegisterForm, self).clean()
```

La récupération des données validée par Django se fait par l'appel de cleaned_data.get() qui dans cet exemple permet de récupérer la valeur des deux mots de passe.

```
raise forms.ValidationError("Le mot de passe doit faire 10 caractères minimum")
```

Cette ligne permet de lever une erreur de formulaire qui sera affichée à l'utilisateur.
Dans cet exemple, on effectue 4 vérifications en plus des vérifications de Django :

- Que le mot de passe soit supérieur ou égal à 10 caractère
- Que les mots de passe soient identiques
- Qu'un utilisateur avec le même username n'existe pas
- Qu'un utilisateur avec la même adresse email n'existe pas

La fonction retourne ensuite la valeur de cleaned_data, et peux également permettre un nouveau niveau d'héritage si besoin.

Ce formulaire nécessite un template pour s'afficher. Pour cela nous allons créer un template générique dans lequel nous pourrons afficher les formulaires standards. Nous allons donc créer le fichier `intranet_phonecenter/templates/utils/form.html` avec le contenu suivant :

```
{% extends "base.html" %}
{% block title %}
    {{ title }}
{% endblock %}
{% block content %}
<div class="container">
  <div class="row">
    <div class="col-sm-9 col-md-7 col-lg-5 mx-auto">
      <div class="card card-signin my-5">
        <div class="card-body">
          <h5 class="card-title text-center">{{ title }}</h5>
          <div class="sub_title"></div>
          <div class="custom_form_embed">
            <form action="{{ url_form }}" method="POST">
              {% csrf_token %}
              {{ form.as_p }}
              <input type="submit" name="Valider">
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}
```

Ce template va recevoir une variable `title` qui va permettre de définir le titre de la page du formulaire.
Ce formulaire surcharge ensuite le bloc `content` en affichant un formulaire dont le champ `action` est définit par la variable `url_form`.
La ligne `{% csrf_token %}` permet d'afficher un champ de formulaire contenant le token CSRF (Cross-site request forgery)
La ligne `{{ form.as_p }}` permet de générer le formulaire Django sous format HTML.

Il faut à présent coder la view qui va interface le formulaire Django avec le template et les models. Pour cela il faut ajouter le code suivant au fichier `users/views.py` :

```
from django.http import HttpResponse, HttpResponseRedirect
from django.contrib.auth import authenticate, login, logout
from django.urls import reverse
from django.shortcuts import render

from .forms import RegisterForm
from .models import UserProfile

# ...

def register(request):
    if request.user.is_authenticated:
        return HttpResponseRedirect(reverse("users:hello"))
    if request.method == 'POST':
        form = RegisterForm(request.POST)
        if form.is_valid():
            username = form.cleaned_data['username']
            email = form.cleaned_data['email']
            raw_password = form.cleaned_data['raw_password']
            user = UserProfile.objects.create_user(
                username=username,
                email=email,
                password=raw_password,
            )
            user.save()
            login(request, user)
            return HttpResponseRedirect(reverse("users:hello"))
    else:
        form = RegisterForm()
    return render(
        request,
        'utils/form.html',
        {
            'url_form': reverse("users:register"),
            'title': "Inscription",
            'form':form,
        })
```


Dans cette vue si un utilisateur est connecté (notamment via l'administration), il est redirigé vers notre page Hello World.
Lorsque la view reçoit des données en POST, elle instancie le formulaire en lui donnant en paramètre les données reçues en POST. Si le formulaire est valide, on récupère les données du formulaire.
Ensuite, on instancie le model UserProfile avec la méthode `create_user()` qui permet de hasher le mot de passe. La variable user est une instance de notre model mais ne correspond pas encore à un enregistrement en base de données. Il faut utiliser la méthode `save()` du model pour enregistrer son état en base de données. Compte tenu du fait que l'instance du model n'est pas lié à un enregistrement en base, la méthode `save()` exécutera une requête de type `INSERT INTO` en table.
Ensuite, on connecte automatiquement le nouvel utilisateur en utilisant la ligne `login(request, user)` puis on le redirige vers la page HelloWorld.
Si la view n'a pas reçu de données en POST (donc si le formulaire n'a pas été posté), on instancie le formulaire sans aucune données.
Dans la fonction `render()` l'appel à `reverse()` permet de générer une URL à partir du nom et du contexte d'une URL définie dans le projet.

Pour que cette view puisse être accédé par l'utilisateur il faut la définir dans le fichier `users/urls.py` en ajoutant la ligne suivante :

```
path('register/', views.register, name="register"),
```

Ceci rend la page accessible à l'URL suivante : localhost:8000/users/register/.
Il est possible d'ajouter un menu dans le fichier `intranet_phonecenter/templates/base.html` en ajoutant les lignes suivantes dans la navbar :

```
<li class="nav-item active">
    <a class="nav-link" href="{% url 'users:register' %}">Inscription</a>
</li>
```



## Crispy Forms

Le formulaire d'inscription fonctionne, mais n'est pas très esthétique. Il est possible d'ajouter du CSS afin de rendre le formulaire plus abordable visuellement mais dans notre recherche de productivité maximale, nous allons utiliser une bibliothèque : django-crispy-forms.
Il faut tout d'abord l'installer en utilisant les commandes suivantes :

```
pip install django-crispy-forms
pip freeze > requirements.txt
```

Il faut ensuite l'ajouter dans la liste des applications installées du projet en modifiant le fichier `intranet_phonecenter/local_settings.py` :

```
INSTALLED_APPS = (
    ...
    'crispy_forms',
)

# ...

CRISPY_TEMPLATE_PACK = 'bootstrap4'
```

La variable CRISPY_TEMPLATE_PACK permet de définir un pack de style spécifique.
Il faut ensuite le formulaire en modifiant le début du contenu du fichier `users/forms.py` :

```
from django import forms

from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit

from .models import UserProfile

class FormWithSubmit(forms.Form):
    helper = FormHelper()
    helper.add_input(Submit('submit', "Valider", css_class="btn btn-lg btn-primary btn-block bg_main"))
    helper.form_method = 'POST'

class RegisterForm(FormWithSubmit):
    # Le contenu du formulaire reste le même
```

Ce fichier permet de créer une classe FormWithSubmit dont le but est d'ajouter les fonctionnalités de la bibliothèque en chargeant le helper FormHelper(). On ajoute ensuite deux comportements à cette classe :

- Un bouton "Valider" pour soumettre le formulaire
- Le fait d'envoyer le formulaire en POST

Ensuite, pour attribuer ces comportements supplémentaires au formulaire, il faut le faire hériter de cette nouvelle classe.

Il faut également modifier le template `intranet_phonecenter/templates/utils/form.html` en ajoutant le chargement des outils de templates de django-crispy-forms :

```
{% load crispy_forms_tags %}
```

Il faut aussi remplacer le formulaire HTML `<form>` et son contenu par la ligne :

```
{% crispy form %}
```

Cette ligne s'occupe de générer ce qu'il faut dont le token CSRF et les comportements que nous avons ajoutés à `FormWithSubmit()`.

Une fois ces étapes effectuées l'affichage du formulaire est conforme à un affichage Bootstrap 4.




## Page de connexion / déconnexion

Après avoir développé la page d'inscription, les fonctionnalités qui viennent ensuite naturellement sont la connexion et déconnexion. Cet exemple va présenter l'utilisation d'un formulaire brut sans utilisation des outils de Django.

Il faut tout d'abord modifier la views `users/views.py` en ajoutant l'import et la view suivante :

```
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect

# ...

@login_required
def logout_view(request):
    logout(request)
    return HttpResponseRedirect(reverse("users:login"))

def login_view(request):
    if request.user.is_authenticated:
        return HttpResponseRedirect(reverse("users:hello"))
    elif 'username' in request.POST and 'password' in request.POST:
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            if request.GET.get('next') is not None:
                return redirect(request.GET['next'])
            else:
                return HttpResponseRedirect(reverse("users:hello"))
        else:
            return render(
                request,
                'users/login.html',
                {
                    "auth_error": True,
                }
            )
    else:
        return render(
            request,
            'users/login.html',
            {}
        )
```

La view logout_view() est très simple. Tout d'abord, elle est préfixée du décorateur @login_required qui permet de la restreindre aux utilisateurs connectés.
Cette view utilise ensuite la méthode logout() (issue de django.contrib.auth) pour déconnecter l'utilisateur. Pour finir, la view redirige l'utilisateur vers la page de connexion.
A l'exception de la redirection finale, la view peut-être testé sans devoir code la connexion, car il est possible de connecté un utilisateur en passant par le module d'administration.

La view login_view() effectue les actions suivantes :
- Elle redirige un utilisateur connecté vers la page HelloWorld
- Si les données username et password n'ont pas été postées elle affiche le template users/login.html
- A l'inverse, si le formulaire a été posté, la view appelle la méthode authenticate() pour vérifier si les données de connexion sont correctes (en renvoyant l'instance du model UserProfile correspondant aux identifiants si c'est le cas).
- Si un utilisateur correspond, la view le connecte en utilisant la méthode login(). Elle redirige ensuite l'utilisateur vers la page suivante s'il a essayé de consulter une page restreinte aux connectés. Sinon l'utilisateur est redirigé vers la page HelloWorld.

Il ajoute ensuite les URLs nécessaires dans le fichiers `users/urls.py` :

```
path('logout/', views.logout_view, name="logout"),
path('login/', views.login_view, name="login"),
```

Il créé ensuite le template `users/templates/users/login.html` avec le contenu suivant :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Connexion
{% endblock %}
{% block content %}
<div class="container">
  <div class="row">
    <div class="col-sm-9 col-md-7 col-lg-5 mx-auto">
      <div class="card card-signin my-5">
        <div class="card-body">
          <h5 class="card-title text-center">Connexion</h5>
          <form class="form-signin" method="post" action="{% url 'users:login' %}">
            {% csrf_token %}
            <div class="form-label-group">
              <input type="text" name="username" class="form-control" placeholder="Nom d'utilisateur ou email" required autofocus>
              <label for="username">Nom d'utilisateur ou email</label>
            </div>
            <div class="form-label-group">
              <input type="password" name="password" class="form-control" placeholder="Mot de passe" required>
              <label for="password">Mot de passe</label>
            </div>
            <button class="btn btn-lg btn-primary btn-block bg_main" type="submit">Connexion</button>
            {% if auth_error %}
              <div class="alert alert-danger" role="alert">
                Nom d'utilisateur ou mot de passe incorrect
              </div>
            {% endif %}
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}
```

Ce template est très simple, il implémente un formulaire HTML avec pour seule fonctionnalité Django la génération du token CSRF.

Pour proposer ces pages à l'utilisateur il est possible de modifier le fichier `intranet_phonecenter/templates/base.html` et d'ajouter dans la navbar :

```
{% if user.is_authenticated %}
  <ul class="navbar-nav mr-auto">
    <li class="nav-item active">
      <a class="nav-link" href="{% url 'users:logout' %}">Déconnexion</a>
    </li>
  </ul>
{% else %}
  <ul class="navbar-nav mr-auto">
    <li class="nav-item active">
      <a class="nav-link" href="{% url 'users:login' %}">Connexion</a>
    </li>
  </ul>
  <ul class="navbar-nav mr-auto">
    <li class="nav-item active">
      <a class="nav-link" href="{% url 'users:register' %}">Inscription</a>
    </li>
  </ul>
{% endif %}
```

La ligne `{% if user.is_authenticated %}` permet de vérifier si l'utilisateur actuel est connecté.
Il ne faut pas oublier de supprimer les anciennes lignes concernant le menu **Inscription**.



## Configuration du compte

Une fonctionnalité pratique serait de permettre à un utilisateur de changer son nom d'affichage (sur les pages où cela est implémenté). Pour cela, il faut tout d'abord créer une page "Mon compte" pour afficher les différentes fonctionnalités liées au compte utilisateur.

Pour cela, on ajoute la view suivante au fichier `users/views.py` :

```
@login_required
def myaccount(request):
    return render(
        request,
        'users/myaccount.html',
    )
```

On ajoute également l'URL suivante au fichier `users/urls.py` :

```
path('myaccount/', views.myaccount, name="myaccount"),
```

On ajoute le template `users/templates/users/myaccount.html` avec le contenu :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Paramétrer mon compte
{% endblock %}
{% block content %}
<h2>Mon compte</h2>
<a href="{% url 'users:account_settings'%}">Paramétrer mon compte</a>
{% endblock content %}
```

On peut aussi ajouter un menu dans la navbar (dans le `{% if user.is_authenticated %}`) pour accéder à la page. Il faut ajouter le code suivant au fichier `intranet_phonecenter/templates/base.html`:

```
<ul class="navbar-nav mr-auto">
    <li class="nav-item active">
        <a class="nav-link" href="{% url 'users:myaccount' %}">{{ user.get_username }}</a>
    </li>
</ul>
```

Pour permettre à l'utilisateur de modifier son nom d'affichage, nous allons utiliser un formulaire Django basé sur un model : le `ModelForm`. Ce type de formulaire est très efficace car il permet d'automatiser la génération des champs du formulaire et l'enregistrement du formulaire.

Pour cela, il faut créer un formulaire de base héritant de `forms.ModelForm` et implémentant django-crispy-forms et nos comportements pré définis. Pour cela, nous devons modifier le fichier users/forms.py et y ajouter (après la déclaration de FormWithSubmit car ça sera un formulaire à surcharger) :

```
class ModelFormWithSubmit(forms.ModelForm):
    helper = FormHelper()
    helper.add_input(Submit('submit', "Valider", css_class="btn btn-lg btn-primary btn-block bg_main"))
    helper.form_method = 'POST'
```

Il faut créer notre nouveau formulaire dans le même fichier en ajoutant :

```
class AccountSettingsForm(ModelFormWithSubmit):

    # Facultatif
    display_name = forms.CharField(
        label = "Nom d'affichage",
        max_length=256,
        )

    class Meta:
        model = UserProfile
        fields = ('display_name', )
```

Ce nouveau formulaire hérite de `ModelFormWithSubmit`. Il définit ensuite un champ de formulaire `display_name` qui est totalement facultatif, mais qui permet de surcharger les comportements définis dans les models.
Nous avons déjà parlé de la class Meta qui permet de définir des comportements propres à la classe. Ici, compte tenu du fait que c'est un formulaire de type ModelForm, il faut définir un model sur lequel se basera le formulaire. Il faut ensuite définir les champs du model qui seront présents dans le formulaire. Dans l'exemple, seul le champ `display_name` pourra être édité.

Il faut ensuite créer la view qui va proposer le formulaire. Pour cela il faut ajouter la view suivante dans le fichier `users/views.py` :

```
# Modifier l'import des forms avec cette ligne :
from .forms import RegisterForm, AccountSettingsForm

# Ajouter cette view
@login_required
def account_settings(request):
    if request.method == 'POST':
        form = AccountSettingsForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
    else:
        form = AccountSettingsForm(instance=request.user)
    return render(
        request,
        'utils/form.html',
        {
            'url_form': reverse("users:register"),
            'title': "Inscription",
            'form':form,
        }
    )
```

La view est réservée aux utilisateurs connectés. Si le formulaire a été posté, il est instancié avec les données POST et l'instance de l'utilisateur connecté. Cela signifie que le formulaire sera initialisé avec les données utilisateurs surchargées par les données du formulaire. Si le formulaire est validé, il est (implicitement le model du formulaire) sauvegardé en base. Étant instancié à partir d'une instance de model, le formulaire sauvegardé donnera lieu à une requête SQL de type UPDATE.
Lorsque le formulaire n'a pas été posté, il est instancié à partir de l'instance de l'utilisateur afin de présenter le formulaire avec les données pré-existantes.

Il faut ensuite ajouter l'URL suivante dans le fichier `users/urls.py` :

```
path('account-settings/', views.account_settings, name="account_settings"),
```

Les ModelForm sont un outil très puissant puisqu'il suffit de quelques lignes pour effectuer les actions suivantes :
- Affichage du formulaire avec les données existantes
- Validation du formulaire basé sur les models (surchargeable)
- Affichage des erreurs
- Enregistrement des modifications.
C'est une de force de Django pour concevoir rapidement une MVP (Minimum Viable Product).

Git :

```
git add --all
git commit -m "Users : account registration + settings"
git tag users_account_registration
```


## Accepter de recevoir les newsletters

Le but est de cette partie est d'ajouter la fonctionnalité qui permet à l'utilisateur d'autoriser le site à lui envoyer des newsletters. Cela va être extrêmement simple en réutilisant le ModelForm qu'on vient de créer.

Pour cela, il faut tout d'abord rajouter le champs dans le model en éditant le fichier `users/models.py` pour ajouter le code suivant dans le model `UserProfile`:

```
newsletter_agreement = models.BooleanField(
    verbose_name = "Recevoir des newsletter",
    help_text = "Une par semaine maximum",
    default=False,
    db_index=True,
    )
```

Il faut ensuite créer et exécuter la migration en utilisant la commande suivante :

```
python manage.py makemigrations
python manage.py migrate
```

Pour permettre à l'utilisateur de modifier ce champ, il faut l'ajouter au formulaire `AccountSettingsForm` du fichier `users/forms.py` :

```
fields = ('display_name', 'newsletter_agreement', )
```

Pour aller plus loin, il est également possible d'éditer le fichier users/admin.py pour permettre de filtrer les utilisateurs en fonction de champs et de l'afficher dans la liste en modifiant la classe `UserProfileAdmin` :

```
list_display = ('username', 'email', 'user_type', 'display_name', 'newsletter_agreement', )
list_filter = ['user_type', 'newsletter_agreement', ]
```

Cette fonctionnalité montre la grande force de Django et notamment de ses ModelForm et de son module d'administration. Il a suffit de 7 lignes de codes et de 2 commandes pour :

- Créer la table
- Afficher le champ dans le formulaire
- Enregistrer les éléments en base de données
- Permettre aux administrateurs de consulter les utilisateurs ayant autorisé ou non l'envoi de newsletter.

Git :

```
git add --all
git commit -m "Users : add newsletter setting"
git tag users_newsletter_setting
```

## Ajout d'une page d'accueil

Pour l'instant, l'URL http://localhost:8000 ne renvoyait absolument rien et donnait donc lieu à une erreur 404. Pour l'exemple, nous allons afficher la page de connexion. Pour cela, il faut éditer le fichier `intranet_phonecenter/urls.py` en ajoutant la ligne suivante dans la liste d'URLs :

```
path('', users.views.login_view),
```

A présent l'URL `http://localhost:8000` affiche la page de connexion.


Git :

```
git add --all
git commit -m "Homepage : add empty URL"
git tag homepage_empty_url
```


## Pages pour attribuer les rôles utilisateurs (CBV)

Pour l'instant, l'attribution d'un utilisateur ne pouvait se faire que par le module d'administration. Pour améliorer l'ergonomie du site, il faut créer trois nouvelles pages chargées de :

- Liste les utilisateurs sans rôle
- Permet de définir le rôle membre d'équipe à un utilisateur
- Permet de définir le rôle client à un utilisateur

Pour cela, il faut tout d'abord créer la view qui permettra de liste les utilisateurs non liés à des membres d'équipe ou des clients. Pour cela, il faut créer la view suivante dans le fichier `users/views.py` :

```
from django.contrib.auth.decorators import login_required, user_passes_test

@user_passes_test(lambda u: u.is_superuser)
def role_attribution(request):
    users = UserProfile.objects.filter(teammember__isnull=True, customer__isnull=True).order_by("-id")
    return render(
        request,
        'users/role_attribution.html',
        {
            'users': users,
        }
    )
```

Dans cette view, nous importons le décorateur `user_passes_test()` qui permet d'autoriser l'accès à un utilisateur selon une condition. Dans ce cas-là, seuls les superusers seront autorisés à accéder à la view.
Dans cette view, nous utilions la queryset suivante pour récupérer les utilisateurs n'étant ni lié à un membre d'équipe ni à un client. Il était également possible de vérifier le champ `user_type`.
Il faut ensuite définir l'URL dans le fichier `users/urls.py` :

```
path('role-attribution/', views.role_attribution, name="role_attribution"),
```

Le template correspondant à la view doit être ajouté dans le fichier `users/templates/users/role_attribution.html` :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
Connexion
{% endblock %}
{% block content %}
<h2>Attribution de rôle</h2>
<table class="table">
    <thead>
        <tr>
            <th scope="col">Username</th>
            <th scope="col">Email</th>
            <th scope="col">
                Membre d'équipe
            </th>
            <th scope="col">
                Client
            </th>
        </tr>
    </thead>
    <tbody>
    {% for user_role in users %}
        <tr>
            <th scope="row">{{ user_role.username }}</th>
            <td>{{ user_role.email }}</td>
            <td>
                <a class="btn btn-primary" href="{% url 'users:role_attribution_teammember' user_id=user_role.id %}" role="button">Membre d'équipe ?</a>
            </td>
            <td>
                <a class="btn btn-primary" href="{% url 'users:role_attribution_customer' user_id=user_role.id %}" role="button">Client ?</a>
            </td>
        </tr>
    {% endfor %}
    </tbody>
</table>
{% endblock content %}
```

Dans ce template, nous effectuons une boucle `for` en utilisant la ligne suivante `{% for user_role in users %}`, ce qui permet d'afficher chaque élément de la queryset. Ce template affiche pour chaque utilisateur deux liens permettant de définir le rôle de membre d'équipe ou le rôle de client.
Il est possible d'ajouter un bouton pour les superuser dans le menu pour accéder à cette page. Pour cela, il faut modifier le fichier `intranet_phonecenter/templates/base.html` en ajoutant dans la navbar le code suivant:

```
{% if request.user.is_superuser %}
<ul class="navbar-nav mr-auto">
    <li class="nav-item active">
        <a class="nav-link" href="{% url 'users:role_attribution' %}">Attribuer des rôles</a>
    </li>
</ul>
{% endif %}
```

Les views permettant d'attribuer un rôle ne seront pas des views standard Django. Nous allons utiliser une fonctionnalité de Django permettant de créer des vues basées sur des models : les CBV (Class Based Views). Nous allons les stocker dans un nouveau fichier `users/cbv.py` avec le contenu suivant :

```
from django.views.generic.edit import CreateView
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.contrib.auth.mixins import UserPassesTestMixin

from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit

from .models import UserProfile, TeamMember, Customer

class TeamMemberCreate(UserPassesTestMixin, CreateView):
    template_name = 'utils/form.html'
    model = TeamMember
    fields = ['support_level', ]

    def test_func(self):
        return self.request.user.is_superuser

    def get_form(self, form_class=None):
       form = super().get_form(form_class)
       form.helper = FormHelper()
       form.helper.add_input(Submit('submit', 'Attribuer', css_class='btn-primary'))
       return form

    def get_form_kwargs(self):
        kwargs = super(TeamMemberCreate, self).get_form_kwargs()
        if kwargs['instance'] is None:
            kwargs['instance'] = TeamMember()
        user = UserProfile.objects.get(pk = self.kwargs['user_id'])
        kwargs['instance'].teammember = user
        user.user_type = 1
        user.save()
        return kwargs

    def get_success_url(self):
        return reverse("users:role_attribution")

class CustomerCreate(UserPassesTestMixin, CreateView):
    template_name = 'utils/form.html'
    model = Customer
    fields = ['credits', ]

    def test_func(self):
        return self.request.user.is_superuser

    def get_form(self, form_class=None):
       form = super().get_form(form_class)
       form.helper = FormHelper()
       form.helper.add_input(Submit('submit', 'Attribuer', css_class='btn-primary'))
       return form

    def get_form_kwargs(self):
        kwargs = super(CustomerCreate, self).get_form_kwargs()
        if kwargs['instance'] is None:
            kwargs['instance'] = Customer()
        user = UserProfile.objects.get(pk = self.kwargs['user_id'])
        kwargs['instance'].customer = user
        user.user_type = 2
        user.save()
        return kwargs

    def get_success_url(self):
        return reverse("users:role_attribution")

```

Les Class Based View se base sur un model et permettent d'effectuer les opérations spécifiques CRUD (Create Read Update Delete) relatives à l'instance. Les différentes CBV sont les suivantes :

- DetailView : Pour afficher le détail d'un model.
- ListView : Pour afficher une liste de model
- CreateView : Pour enregistrer un nouveau model
- UpdateView : Pour modifier un model
- DeleteView : Pour supprimer un model

Dans cet exemple, nous utiliserons la CBV CreateView pour créer les models TeamMember et Customer.

Dans ce fichier, nous avons défini les classes `TeamMemberCreate` et `CustomerCreate`. Ces classes sont construites de la même façon, nous allons donc expliquer en détail la classe `TeamMemberCreate`. Cette explication est valable également pour `CustomerCreate`.

La classe TeamMemberCreate hérite des classes `UserPassesTestMixin` et `CreateView`. La première classe (`UserPassesTestMixin`) permet d'intégrer des fonctionnalités permettant d'interdire l'accès à la view à certains utilisateurs. La deuxième classe (`CreateView`) apporte toutes les fonctionnalités de la CBV avec la génération du formulaire (génération dans le templates, validation, enregistrement).
Dans cette classe, nous définissons 3 propriétés :

- template_name : qui permet de définir le template affichant le formulaire. Dans ce cas-là, nous réutilisons notre template standard.
- model : Le modèle sur lequel sera basé le formulaire
- fields : Les champs de formulaire

Les Class Based Views sont très proches des ModelForm (avec la définition du `model` et des `fields`), leur avantage principal est de ne pas avoir à coder la view lorsque le besoin est simple et qu'il n'y a que très peu de traitements spécifiques.

Cette classe pourrait s'arrêter là, puisque les 3 propriétés définies sont les seuls éléments nécessaires pour que la CBV soit fonctionnelle. Cependant, nous souhaitons intégrer des comportements supplémentaires à la classe :

- test_func() : permet de spécifier si l'utilisateur à accès à la view. Dans ce cas-là, nous voulons interdire l'accès aux utilisateurs qui ne sont pas superuser. Nous aurions également pû autoriser l'accès au teammember.
- get_form() : permet d'ajouter les comportements django-crispy-forms au formulaire.
- get_form_kwargs() : permets de récupérer les arguments passés à l'URL. Dans notre cas, cela nous permet de récupérer l'utilisateur sélectionné en fonction de son id passé en paramètre. Cela nous permet de spécifier le champ teammember du model TeamMember avec l'instance de l'utilisateur sélectionné.
- get_success_url() : permet de spécifier l'URL de redirection si la validation du formulaire et l'enregistrement du model a réussi.

Il faut maintenant s'occuper des URLs en important notre module cbv et en ajoutant les URLs au fichier `users/urls.py` :

```
from users import views, cbv

# ...

path(
    'role-attribution-teammember-<int:user_id>/',
    cbv.TeamMemberCreate.as_view(),
    name="role_attribution_teammember"
    ),
path(
    'role-attribution-customer-<int:user_id>/',
    cbv.CustomerCreate.as_view(),
    name="role_attribution_customer"
    ),
```

Cette Class Based view s'est totalement adaptée à nos besoins et nous économise le code permettant de générer la view, de générer le formulaire et de sauvegarder le model. Les CBV sont très adaptés lorsque le formulaire et la view ne nécessite pas une grande personnalisation. Pour des cas complexes, les comportements spécifiques seront plus complexes à gérer avec des CBV, ce qui apportera de la complexité inutile.


```
git add --all
git commit -m "Users Roles : Settings"
git tag users_roles_settings
```

## Mise en place des appels

Le but de cette section est de mettre en place l'enregistrement d'appels effectués par les membre d'équipe.

Avant même de commencer le développement, il est important de savoir les données que nous allons enregistrer. Il pourrait être possible d'attribuer des étiquettes (*Tags*) aux appels.
Chaque appel sera lié à un client et à un membre d'équipe. Les appels contiendront également un champ permettant de savoir si le problème a été résolu.

Il faut tout d'abord ajouter les nouveaux models en remplaçant le contenu du fichier `calls/models.py` par :


```
from django.db import models
from django.core.validators import MaxValueValidator, MinValueValidator

from users.models import BaseModel, UserProfile, TeamMember, Customer

class CallCategory(BaseModel):
    name = models.CharField(
        verbose_name = "Nom",
        max_length = 200,
        )
    urgent_level = models.PositiveSmallIntegerField(
        verbose_name = "Niveau d'urgence",
        help_text = "Entre 1 (bas niveau d'urgence) et 10 (urgence critique)",
        default=3,
        validators=[
            MaxValueValidator(10),
            MinValueValidator(1)
            ]
        )

    def __str__(self):
        return "%s (%d)" % (self.name, self.urgent_level)

    class Meta:
        verbose_name = "Catégorie d'appel"
        verbose_name_plural = "Catégories d'appels"

class CallTag(BaseModel):
    name = models.CharField(
        verbose_name = "Nom",
        max_length = 100,
        )

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "Tag d'appel"
        verbose_name_plural = "Tags d'appels"

class Call(BaseModel):
    title = models.CharField(
        verbose_name="Titre",
        max_length=200,
        )

    customer = models.ForeignKey(
        Customer,
        on_delete=models.SET_NULL,
        verbose_name = "Client",
        db_index=True,
        null=True,
        blank=True,
        default=None,
        )

    teammember = models.ForeignKey(
        "users.TeamMember",
        on_delete=models.SET_NULL,
        verbose_name = "Membre d'équipe",
        db_index=True,
        null=True,
        blank=True,
        default=None,
        )

    call_category = models.ForeignKey(
        CallCategory,
        on_delete=models.SET_NULL,
        verbose_name = "Catégorie",
        db_index=True,
        null=True,
        blank=True,
        default=1,
        )

    tags = models.ManyToManyField(
        "CallTag",
        verbose_name="Tags",
        blank=True,
        )

    content = models.TextField(
        verbose_name="Contenu de l'appel",
        )

    solved = models.BooleanField(
        verbose_name = "Résolu",
        default=False,
        db_index=True,
        )

    solved_date = models.DateTimeField(
        null=True,
        blank=True,
        default=None,
        verbose_name="Date de résolution",
        )

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "Appel"
        verbose_name_plural = "Appels"
```

Ces models contiennent les spécifications expliquées précédemment.

Il faut ensuite générer la migration et l'exécuter
```
python manage.py makemigrations
python manage.py migrate
```

Nous allons ensuite paramétrer le module d'administration avec ces nouveaux models en définissant le contenu suivant dans le fichier `calls/admin.py` :

```
from django.contrib import admin

from .models import CallCategory, CallTag, Call

class CallAdmin(admin.ModelAdmin):
    list_display = ('id', 'created', 'solved_date', 'customer', 'teammember', 'solved', 'title', )
    list_filter = ['solved', 'teammember', 'tags']
    list_editable = ['solved', 'teammember', ]
    search_fields = ['customer', 'teammember', 'title', ]

admin.site.register(CallCategory)
admin.site.register(CallTag)
admin.site.register(Call, CallAdmin)
```

Nous allons ensuite créer la page qui permettra d'ajouter un nouvelle appel.
Pour cela il faut tout d'abord créer le formulaire en définissant le contenu suivant dans le fichier `calls/forms.py` :


```
from django import forms

from users.forms import ModelFormWithSubmit
from .models import Call, CallTag


class NewCallForm(ModelFormWithSubmit):

    tags = forms.ModelMultipleChoiceField(
        widget=forms.CheckboxSelectMultiple,
        queryset=CallTag.objects.all(),
        required=False,
        )

    class Meta:
        model = Call
        fields = ('title', 'customer', 'call_category', 'tags', 'content', 'solved', )
```

Il ne faut pas oublier d'ajouter des tags et des catégories d'appels à partir du module d'administration pour avoir des tests cohérents !

Il faut ensuite ajouter la view en définissant le contenu suivant dans le fichier `calls/views.py` :

```
from django.shortcuts import render
from django.contrib.auth import authenticate, login, logout
from django.urls import reverse
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import HttpResponseRedirect


# Create your views here.
from .forms import NewCallForm
from .models import Call
from users.views import is_teammember


@user_passes_test(is_teammember)
def new_call(request):
    if request.method == 'POST':
        form = NewCallForm(request.POST)
        if form.is_valid():
            form.instance.teammember = request.user.teammember
            form.save()
    else:
        form = NewCallForm()
    return render(
        request,
        'utils/form.html',
        {
            'title': "Nouvel Appel",
            'form':form,
        }
    )

```

Ajouter au fichier `users/views.py` :

```
def is_teammember(user=None):
    if not user or user.is_anonymous:
        return False
    return user.is_teammember()
```

Pour ajouter l'URL il faut ensuite définir l'URL en définissant le contenu suivant de le fichier `calls/urls.py` :

```
from django.urls import path

from calls import views

app_name = 'calls'

urlpatterns = [
    path('new_call/', views.new_call, name="new_call"),
]
```

Dans le fichier `users/models.py`, il faut ajouter au model UserProfile les méthodes suivantes :

```
def is_teammember(self):
    return self.user_type == 1

def is_customer(self):
    return self.user_type == 2
```

Il faut ensuite ajouter l'URL dans le fichier `intranet_phonecenter/templates/base.html` dans la section `{% if user.is_authenticated %}`:
```
{% if request.user.is_teammember %}
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <a class="nav-link" href="{% url 'calls:new_call' %}">Nouvel appel</a>
      </li>
    </ul>
{% endif %}
```

Avant de tester il faut ajouter des tags depuis le module d'administration. Il faut ensuite se connecter en tant que membre d'équipe pour ajouter des appels. Rien n'est prévu pour les visualiser à part le module d'administration.

Dans `local_settings.py` ajouter afin de gérer la redirection vers l'URL de connexion lorsque l'utilisateur n'a pas accès à une page.

```
LOGIN_URL = 'users:login'
```

Git

```
git add --all
git commit -m "Calls : New call"
git tag calls_new_call
```

# CRUD Calls


L'acronyme CRUD signifie Create Read Update and Delete.
Ce terme est très utilisé chez les développeurs pour désigner les opérations propres aux données.
Ici le but est de permettre de lister, consulter, modifier et supprimer les appels téléphoniques.

Pour lister les appels, il faut tout d'abord ajouter la view suivante dans le fichier `calls/views.py` :

```
@user_passes_test(is_teammember)
def call_list(request):
    calls = Call.objects.filter(teammember = request.user.teammember).order_by("-solved", "-created")
    return render(
        request,
        'calls/call_list.html',
        {
            'calls': calls,
        }
    )
```

Cette view n'est accessible qu'aux membres d'équipe. Chaque membre d'équipe ne voit que les appels qui lui ont été confié en affichant en premier les appels non résolus.

Il faut rajouter l'URL de la view dans le fichier `calls/urls.py` :

```
path('call_list/', views.call_list, name="call_list"),
```

Pour finir, il faut créer le template `calls/templates/calls/call_list.html` avec le contenu suivant :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Liste d'appels
{% endblock %}
{% block content %}
    <a class="btn btn-primary btn-block" href="{% url 'calls:new_call' %}" role="button">Nouvel appel</a>

    <h2>Liste d'appels</h2>
    <table class="table">
        <thead>
            <tr>
                <th scope="col">Appel</th>
                <th scope="col">Client</th>
                <th scope="col">
                    Résolu
                </th>
                <th>Modifier</th>
                <th>Supprimer</th>
            </tr>
        </thead>
        <tbody>
        {% for call in calls %}
            <tr>
                <th scope="row">{{ call }}</th>
                <td>{{ call.customer }}</td>
                <td>
                    {% if call.solved %}
                        ✅
                    {% else %}
                        ❌
                    {% endif %}
                </td>
                <td>
                    <a class="btn btn-primary" href="{% url 'calls:call_edit' call.id %}">Modifier</a>
                </td>
                <td>
                    <a class="btn btn-primary" href="{% url 'calls:call_delete' call.id %}">Supprimer</a>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
{% endblock content %}
```

Dans ce template, on a prévu plusieurs comportements :

- Les appels téléphoniques pourront être créés à partir d'ici.
- Une émoticône sera affichée en fonction de la résolution ou non de l'appel.
- La liste permettra de modifier chaque appel
- La liste permettra de supprimer chaque appel

Ce template ne peut pas être affiché pour le même car les routes pour la modification et la suppression n'existe pas.

Compte tenu du fait que le template permet d'ajouter un appel, nous allons modifier le fichier `intranet_phonecenter/templates/base.html` en remplaçant la ligne :

```
<a class="nav-link" href="{% url 'calls:new_call' %}">Nouvel appel</a>
```

par la ligne

```
<a class="nav-link" href="{% url 'calls:call_list' %}">Liste d'appels</a>
```

Pour permettre l'édition des appels il faut ajouter la view suivante dans le fichier `calls/views.py` :

```
# imports : 
from django.shortcuts import render, get_object_or_404

@user_passes_test(is_teammember)
def call_edit(request, call_id=None):
    current_instance = None
    if call_id:
        # current_instance = Call.objects.get(id = call_id, teammember = request.user.teammember)
        # Equivalent à la ligne du bas sans la gestion de levée d'exption 404
        current_instance = get_object_or_404(Call, pk = call_id, teammember = request.user.teammember)

    if request.method == 'POST':
        form = NewCallForm(request.POST, instance = current_instance)
        if form.is_valid():
            if not current_instance:
                form.instance.teammember = request.user.teammember
            form.save()
    else:
        form = NewCallForm(instance = current_instance)
    return render(
        request,
        'utils/form.html',
        {
            'title': "Appel",
            'form':form,
        }
    )
```


Dans cette view, nous effectuons un filtre supplémentaire sur le `teammember` lors de notre queryset. C'est une mesure de sécurité élémentaire pour éviter qu'un membre d'équipe n'accède aux appels d'un autre membre d'équipe.

Il faut rajouter l'URL de la view dans le fichier `calls/urls.py` :

```
path('call_edit-<int:call_id>/', views.call_edit, name="call_edit"),
```


Concernant la suppression des appels, nous allons l'implémenter en utilisant les CBV Django.
Pour des raisons de simplification, les membres d'équipe pourront supprimer leurs appels. Il est évident que dans un vrai centre d'appel ça ne sera pas le cas.

Il faut tout d'abord créer le CBV en créant le fichier `calls/cbv.py` avec le contenu suivant :


```
from django.views.generic import DeleteView
from django import http
from django.contrib.auth.mixins import UserPassesTestMixin
from django.urls import reverse

from .models import Call


class CallDeleteView(UserPassesTestMixin, DeleteView):
    template_name = 'utils/delete_view.html'
    model = Call

    def test_func(self):
        self.object = self.get_object()
        return self.request.user.is_teammember() and self.object.teammember == self.request.user.teammember

    def delete(self, request, *args, **kwargs):
        self.object = self.get_object()
        if self.object.teammember == self.request.user.teammember:
            success_url = self.get_success_url()
            self.object.delete()
            return http.HttpResponseRedirect(success_url)
        else:
            return http.HttpResponseForbidden("Cannot delete other's calls")

    def get_success_url(self):
        return reverse("calls:call_list")
```

Pour éviter une attaque par CSRF, cette view fonctionne en deux temps en passant par le POST d'un formulaire.
Pour créer ce formulaire, nous allons créer le fichier `intranet_phonecenter/templates/utils/delete_view.html` avec le contenu suivant :


```
{% extends "base.html" %}
{% block title %}
    Confirmation
{% endblock %}
{% block content %}
  <div class="container">
    <div class="row">
      <div class="col-sm-9 col-md-7 col-lg-5 mx-auto">
        <div class="card card-signin my-5">
          <div class="card-body">
            <div class="sub_title"></div>
            <div class="custom_form_embed">
                <form method="post">{% csrf_token %}
                    <p>Etes-vous sur de vouloir supprimer cet élément : "{{ object }}"?</p>
                    <input type="submit" value="Confirm">
                </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
{% endblock content %}
```

Dans le fichier `calls/urls.py` il faut ajouter l'import des CBV et l'URL vers la CBV :

```
#Import :
from calls import cbv

# A ajouter à urlpatterns
path(
    'call_delete-<int:pk>/',
    cbv.CallDeleteView.as_view(),
    name="call_delete"
    ),
```

Pour que l'ajout d'appels soit plus user friendly, il est possible de rediriger l'utilisateur vers la liste des appels après la création d'un nouvel appel. Pour cela, il faut modifier le fichier `calls/views.py` et ajouter le code suivant :

```
# Dans les imports :
from django.http import HttpResponseRedirect

# Dans la view new_call(), après la ligne form.save()
return HttpResponseRedirect(reverse("calls:call_list"))
```


Git

```
git add --all
git commit -m "Calls : CRUD"
git tag calls_crud
```

# Gestion des appels

A présent, il serait utile de rajouter plus de fonctionnalités métiers sur la gestion des appels, à savoir :

- Permettre à un utilisateur de créer un nouvel appel.
- Permettre aux membres d'équipe de prendre un appel en charge
- Permettre au client de modifier le contenu d'un appel.

Pour cela, il faut ajouter les formulaires suivants au fichier `call/forms.py` :

```
class NewCustomerCallForm(NewCallForm):

    class Meta:
        model = Call
        fields = ('title', 'call_category', 'tags', 'content', )


class CustomerCallEditForm(ModelFormWithSubmit):

    class Meta:
        model = Call
        fields = ('content', )


class CallEditTeammemberForm(ModelFormWithSubmit):

    class Meta:
        model = Call
        fields = ('teammember', )
```

Il faut ensuite modifier le fichier `calls/views.py` avec le nouveau contenu suivant :

```
from django.shortcuts import render
from django.contrib.auth import authenticate, login, logout
from django.urls import reverse
from django.contrib.auth.decorators import login_required, user_passes_test
from django.db.models import Q
from django.http import HttpResponseRedirect

from .forms import NewCallForm, NewCustomerCallForm, CustomerCallEditForm
from .forms import CallEditTeammemberForm
from .models import Call
from users.views import is_teammember, is_customer, is_customer_or_teammember


@user_passes_test(is_teammember)
def new_call(request):
    if request.method == 'POST':
        form = NewCallForm(request.POST)
        if form.is_valid():
            form.instance.teammember = request.user.teammember
            form.save()
            return HttpResponseRedirect(reverse("calls:call_list"))
    else:
        form = NewCallForm()
    return render(
        request,
        'utils/form.html',
        {
            'title': "Nouvel Appel",
            'form':form,
        }
    )

@user_passes_test(is_customer_or_teammember)
def call_list(request):
    calls = None
    template_name = ""
    if request.user.is_customer():
        calls = Call.objects.filter(
            customer = request.user.customer,
            ).order_by(
                "-solved",
                "-created",
            )
        template_name = "calls/call_list_customer.html"
    if request.user.is_teammember():
        calls = Call.objects.filter(
            teammember = request.user.teammember,
            ).order_by(
                "-solved",
                "-created",
            )
        template_name = "calls/call_list.html"
    return render(
        request,
        template_name,
        {
            'calls': calls,
        }
    )

@user_passes_test(is_teammember)
def call_edit(request, call_id=None):
    current_instance = None
    if call_id:
        try:
            current_instance = Call.objects.get(
                Q(id = call_id),
                Q(teammember = request.user.teammember) | Q(teammember__isnull=True),
                )
        except Call.DoesNotExist as e:
            # Redirection
            # 403
            # 404
            pass
    form_class = NewCallForm
    if current_instance and not current_instance.teammember:
        form_class = CallEditTeammemberForm
    if request.method == 'POST':
        form = form_class(request.POST, instance = current_instance)
        if form.is_valid():
            if not current_instance:
                form.instance.teammember = request.user.teammember
            form.save()
            return HttpResponseRedirect(reverse("calls:call_list"))
    else:
        form = form_class(instance = current_instance)
    return render(
        request,
        'utils/form.html',
        {
            'title': "Appel",
            'form':form,
        }
    )

@user_passes_test(is_customer)
def new_call_customer(request):
    if request.method == 'POST':
        form = NewCustomerCallForm(request.POST)
        if form.is_valid():
            form.instance.customer = request.user.customer
            form.save()
    else:
        form = NewCustomerCallForm()
    return render(
        request,
        'utils/form.html',
        {
            'title': "Nouvelle demande",
            'form':form,
        }
    )


@user_passes_test(is_customer)
def call_edit_customer(request, call_id):
    current_instance = Call.objects.get(id = call_id, customer = request.user.customer)
    if request.method == 'POST':
        form = CustomerCallEditForm(request.POST, instance = current_instance)
        if form.is_valid():
            form.save()
    else:
        form = CustomerCallEditForm(instance = current_instance)
    return render(
        request,
        'utils/form.html',
        {
            'title': "Appel",
            'form':form,
        }
    )


@user_passes_test(is_teammember)
def call_list_no_teammember(request):
    calls = Call.objects.filter(teammember__isnull=True).exclude(solved=True).order_by("-created")
    return render(
        request,
        'calls/call_list.html',
        {
            'calls': calls,
        }
    )


```

Les modifications de ce fichier sont :

- Ajout de l'import de Q qui va être utilisé dans l'édition des appels
- Ajout des imports des nouveaux formulaires
- Ajout des fonctions `is_customer()` et `is_customer_or_teammember()` pour pouvoir autoriser l'accès aux pages.
- Modification de la view `call_list()` pour l'adapter aux clients et membre d'équipe. Rien n'aurait empêcher de faire 2 views.
- Modification de la view `call_edit()` afin de gérer 2 formulaires différents pour pouvoir prendre un appel ou modifier les différentes données de l'appel. L'objet Q de Django permet de faire des conditions de type AND et OR (là où les querysets standards fonctionnent avec AND par défaut). Dans ce cas là, on va chercher un call en fonction de son id et on ne le récupère que si il n'a pas de membre d'équipe de défini ou alors si ce membre d'équipe est l'utilisateur connecté.
- Ajout de la view `new_call_customer()` qui permet au client de faire une nouvelle demande.
- Ajout de la view `call_edit_customer()` qui permet au client de faire une nouvelle demande.


Dans le model UserProfile du fichier `users/models.py` il faut ajouter ces 2 méthodes :

```
    def is_teammember(self):
        return self.user_type == 1

    def is_customer(self):
        return self.user_type == 2

    def is_customer_or_teammember(self):
        return self.is_teammember() or self.is_customer()
```

Dans le fichier `users/view.py` ajouter les fonctions : 

```
def is_customer(user=None):
    if not user or user.is_anonymous:
        return False
    return user.is_customer()

def is_customer_or_teammember(user=None):
    if not user or user.is_anonymous:
        return False
    return user.is_customer_or_teammember()
```


Il faut ensuite créer le template `calls/templates/calls/call_list_customer.html` avec le contenu suivant :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Liste d'appels
{% endblock %}
{% block content %}
    <a class="btn btn-primary btn-block" href="{% url 'calls:new_call_customer' %}" role="button">Nouvel appel</a>

    <h2>Liste d'appels</h2>
    <table class="table">
        <thead>
            <tr>
                <th scope="col">Appel</th>
                <th scope="col">Intervenant</th>
                <th scope="col">
                    Résolu
                </th>
                <th>Modifier</th>
            </tr>
        </thead>
        <tbody>
        {% for call in calls %}
            <tr>
                <th scope="row">{{ call }}</th>
                <td>{{ call.teammember }}</td>
                <td>
                    {% if call.solved %}
                        ✅
                    {% else %}
                        ❌
                    {% endif %}
                </td>
                <td>
                    <a class="btn btn-primary" href="{% url 'calls:call_edit_customer' call.id %}">Modifier</a>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
{% endblock content %}
```

Dans le fichier `calls/urls.py` il faut ajouter les URLs suivantes :

```
path('call_edit_customer-<int:call_id>/', views.call_edit_customer, name="call_edit_customer"),
path('new_call_customer/', views.new_call_customer, name="new_call_customer"),
path('call_list_no_teammember/', views.call_list_no_teammember, name="call_list_no_teammember"),
```

Dans le template `intranet_phonecenter/templates/base.html` dans la section réservée aux membres d'équipe il faut ajouter le menu suivant :

```
<ul class="navbar-nav mr-auto">
  <li class="nav-item active">
    <a class="nav-link" href="{% url 'calls:call_list_no_teammember' %}">Appels à prendre</a>
  </li>
</ul>
```

Et ajouter une nouvelle section réservée au client : 

```
{% if request.user.is_customer %}
  <ul class="navbar-nav mr-auto">
    <li class="nav-item active">
      <a class="nav-link" href="{% url 'calls:new_call_customer' %}">Demande d'assistance</a>
    </li>
  </ul>
{% endif %}
```

Il faut aussi extraire le menu de liste d'appels pour qu'il soit visible des utilisateurs connecté.

Pour l'instant, un membre d'équipe a la possibilité de définir un autre membre d'équipe que lui-même pour prendre l'appel.
Il est possible de n'autoriser que les superuser à définir un autre membre d'équipe qu'eux-même. Pour cela, il faut ajouter la méthode suivante dans le formulaire `CallEditTeammemberForm` du fichier `calls/forms.py` :

```
from users.models import TeamMember

def restrict(self, user):
    if not user.is_superuser:
        print(TeamMember.objects.filter(teammember_id=user.id).query)
        self.fields['teammember'].queryset = TeamMember.objects.filter(teammember_id=user.id)
```

Il faut ensuite, dans le fichier `calls/views.py` modifier la view `call_edit` avec le code suivant :

```
@user_passes_test(is_teammember)
def call_edit(request, call_id=None):
    current_instance = None
    if call_id:
        current_instance = Call.objects.get(
            Q(id = call_id),
            Q(teammember = request.user.teammember) | Q(teammember__isnull=True),
            )
    form_class = NewCallForm
    if current_instance and not current_instance.teammember:
        form_class = CallEditTeammemberForm
    if request.method == 'POST':
        form = form_class(request.POST, instance = current_instance)
        if form_class == CallEditTeammemberForm:
            form.restrict(request.user)
        if form.is_valid():
            if not current_instance:
                form.instance.teammember = request.user.teammember
            form.save()
    else:
        form = form_class(instance = current_instance)
        if form_class == CallEditTeammemberForm:
            form.restrict(request.user)
    return render(
        request,
        'utils/form.html',
        {
            'title': "Appel",
            'form':form,
        }
    )
```

Dans cette nouvelle view, lorsque le formulaire correspond à une instance de la classe `CallEditTeammemberForm`, nous exécutons la méthode de `restrict()`.

Git

```
git add --all
git commit -m "Calls : advanced management"
git tag calls_advanced_management
```


# Notation des appels


Il est possible d'imaginer que nous souhaitions permettre aux clients de donner leur avis sur la qualité de leur prise en charge. Pour cela, nous allons ajouter une notation sous forme d'étoile.
Une page permettrait de visualiser les appels mal notés afin de rapidement recontacter le client pour améliorer la satisfaction client.

Pour cela, il faut ajouter dans le fichier `calls/models.py` le champ suivant ainsi que la méthode suivante :

```

    rating = models.PositiveSmallIntegerField(
        db_index=True,
        null=True,
        blank=True,
        default=None,
        validators=[
            MaxValueValidator(10),
            MinValueValidator(1)
            ]
        )

    def display_rating(self):
        if self.rating:
            return "⭐"*self.rating+"⭒"*(10-self.rating)
        return ""
```


Dans `calls/forms.py`, on ajoute le formulaire suivant :

```
class CallRatingForm(ModelFormWithSubmit):

    class Meta:
        model = Call
        fields = ('rating', )
```

Dans `calls/views.py`, on ajoute l'import et la view suivante :

```
from .forms import CallEditTeammemberForm, CallRatingForm


@user_passes_test(is_customer)
def call_rating(request, call_id):
    current_instance = Call.objects.get(id = call_id, customer = request.user.customer, solved = True)
    if request.method == 'POST':
        form = CallRatingForm(request.POST, instance = current_instance)
        if form.is_valid():
            form.save()
    else:
        form = CallRatingForm(instance = current_instance)
    return render(
        request,
        'utils/form.html',
        {
            'title': "Noter la prestation",
            'form':form,
        }
    )

@user_passes_test(lambda u: u.is_superuser)
def bad_calls(request):
    calls = Call.objects.filter(
        rating__lte=5
        ).order_by(
            "-created",
        )
    return render(
        request,
        "calls/call_list.html",
        {
            'calls': calls,
        }
    )

```

Il faut modifier le template `calls/templates/calls/call_list.html` en affichant la notation avec le contenu suivant :


```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Liste d'appels
{% endblock %}
{% block content %}
    <a class="btn btn-primary btn-block" href="{% url 'calls:new_call' %}" role="button">Nouvel appel</a>

    <h2>Liste d'appels</h2>
    <table class="table">
        <thead>
            <tr>
                <th scope="col">Appel</th>
                <th scope="col">Client</th>
                <th scope="col">
                    Résolu
                </th>
                <th>Modifier</th>
                <th>Supprimer</th>
                <th>Note</th>
            </tr>
        </thead>
        <tbody>
        {% for call in calls %}
            <tr>
                <th scope="row">{{ call }}</th>
                <td>{{ call.customer }}</td>
                <td>
                    {% if call.solved %}
                        ✅
                    {% else %}
                        ❌
                    {% endif %}
                </td>
                <td>
                    {% if not call.solved %}
                        <a class="btn btn-primary" href="{% url 'calls:call_edit' call.id %}">Modifier</a>
                    {% endif %}
                </td>
                <td>
                    {% if call.teammember and not call.solved %}
                        <a class="btn btn-primary" href="{% url 'calls:call_delete' call.id %}">Supprimer</a>
                    {% endif %}
                </td>
                <td>
                    {% if call.solved %}
                        {% if call.rating %}
                          {{ call.display_rating }}
                        {% endif %}
                    {% endif %}
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
{% endblock content %}

```

Il faut ensuite faire la même chose avec le template `calls/templates/calls/call_list_customer.html` :

```
{% extends "base.html" %}
{% load static %}
{% load i18n %}
{% block title_html %}
    Liste d'appels
{% endblock %}
{% block content %}
    <a class="btn btn-primary btn-block" href="{% url 'calls:new_call_customer' %}" role="button">Nouvel appel</a>

    <h2>Liste d'appels</h2>
    <table class="table">
        <thead>
            <tr>
                <th scope="col">Appel</th>
                <th scope="col">Intervenant</th>
                <th scope="col">
                    Résolu
                </th>
                <th>Modifier</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
        {% for call in calls %}
            <tr>
                <th scope="row">{{ call }}</th>
                <td>{{ call.teammember }}</td>
                <td>
                    {% if call.solved %}
                        ✅
                    {% else %}
                        ❌
                    {% endif %}
                </td>
                <td>
                    <a class="btn btn-primary" href="{% url 'calls:call_edit_customer' call.id %}">Modifier</a>
                </td>
                <td>
                    {% if call.solved %}
                        {% if call.rating %}
                          {{ call.display_rating }}
                        {% else %}
                            <a class="btn btn-primary" href="{% url 'calls:call_rating' call.id %}">Evaluer</a>
                        {% endif %}
                    {% else %}
                        A noter après résolution
                    {% endif %}
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
{% endblock content %}
```

Dans le template `intranet_phonecenter/templates/base.html`, dans la section réservée aux superusers il faut ajouter le menu suivant :

```
<ul class="navbar-nav mr-auto">
  <li class="nav-item active">
    <a class="nav-link" href="{% url 'calls:bad_calls' %}">Mauvais appels</a>
  </li>
</ul>
```

Il faut ajouter les URLs suivantes au fichiers `call/urls.py` :

```
path('call_rating-<int:call_id>/', views.call_rating, name="call_rating"),
path('bad_calls/', views.bad_calls, kwargs = {'call_id':3}, name="bad_calls"),
```


Git

```
git add --all
git commit -m "Calls : rating"
git tag calls_rating
```


# Affichage notation par Template tags

Pour l'affichage des données comme les notations, plutôt que d'avoir une méthode dans le model (qui n'est ici pas une bonne pratique car cela est relatif à l'affichage), il est préférable d'utiliser les templates tags personnalisés en créant un filtre spécifique.
Pour cela, il faut créer le fichier : `calls/templatetags/calls_filters.py` avec le contenu suivant :

```
from django import template

register = template.Library()

@register.filter()
def rating_stars(value, with_empty_stars = True):
    if value:
        if with_empty_stars:
            return "⭐"*value+"⭒"*(10-value)
        else:
            return "⭐"*value
    else:
        return ""
```

Dans le dosser `calls/templatetags`, il ne faut pas oublier d'ajouter un fichier `__init__.py` afin que le dossier soit reconnu comme un module python.

Il faut ensuite modifier les lignes `{{ call.display_rating }}` des templates `calls/templates/calls/call_list_customer.html` et `calls/templates/calls/call_list.html` avec le contenu suivant :

```
{{ call.rating | rating_stars }}
```

Cette ligne va appeller le filtre `rating_stars()` avec pour seul argument la valeur de la variable sur lequel le filtre est utilisé.

Pour n'afficher que les étoiles pleines et non les vides il est possible d'utiliser la syntaxe suivante où `False` sera définit en argument `with_empty_stars` du filtre personnalisé.

```
{{ call.rating | rating_stars:False }}
```


Et ne pas oublier au début de ces templates de charger les templates tags personnalisés :

```
{% load calls_filters %}
```

Git

```
git add --all
git commit -m "Calls : rating display with filter"
git tag calls_rating_filter
```


# Commande Django personnalisée

Sur de très nombreux projets, il est nécessaire de pouvoir exécuter périodiquement des traitements spécifiques. Il ne faut pas faire, comme de trop nombreux déveleppeurs le font, des crons avec appel HTTP vers des URLs. Cela occupe beaucoup trop Apache, soumet le traitement à la contrainte de timeout, limite les performances, etc.
Pour cela, il est possible de créer des commandes Django personnalisées. Dans notre cas, nous pouvons imaginer une commande qui supprime les appels non résolus de plus de 2 ans.
Créer le fichier `calls/management/commands/remove_old_calls.py` avec le contenu suivant :

```
import os
import sys
import datetime
import time

from django.core.management.base import BaseCommand
import django.utils.timezone
from django.conf import settings

from users.utils import lock
from calls.models import Call

CURRENT_FILE_DIR = os.path.dirname(os.path.abspath(__file__))

class Command(BaseCommand):

    @lock(os.path.join(CURRENT_FILE_DIR, os.path.basename(__file__)+".lock"))
    def handle(self, *args, **options):
        now = datetime.datetime.utcnow()
        last_day = now - datetime.timedelta(365*2)
        Call.objects.filter(solved_date__lte=last_day).exclude(solved=True).delete()
        with open(os.path.join(settings.LOG_DIR, os.path.basename(__file__)+"_exec.log"), "a") as f:
            f.write(str(datetime.datetime.utcnow())+" ==> Elapsed %s" % (datetime.datetime.utcnow() - now)+"\n")

```

Dans les settings ajouter :

```
import os

LOG_DIR = os.path.join(BASE_DIR, "logs")
```

Créer le dossier `logs` et y ajouter un fichier `.gitkeep`.

Il faut ajouter au fichier `.gitignore` :

```
logs/*
!logs/.gitkeep
```

Nous allons créer le mécanisme de fichiers de lock dans le fichier `users/utils.py` :

```
import os
import sys
import datetime


def lock(lock_file):
    """
    Usage:
        @lock('file.lock')
        def run():
            # Function action
    """
    def decorator(target):

        def wrapper(*args, **kwargs):

            if os.path.exists(lock_file):
                raise Exception('Unable to get exclusive lock.')
            else:
                with open(lock_file, "w") as f:
                    d = datetime.datetime.utcnow()
                    epoch = datetime.datetime(1970, 1, 1)
                    t = (d - epoch).total_seconds()
                    f.write(str(t))

            # Execute the target
            result = target(*args, **kwargs)

            remove_attempts = 10
            os.remove(lock_file)
            while os.path.exists(lock_file) and remove_attempts >= 1:

                os.remove(lock_file)
                remove_attempts-=1

            return result
        return wrapper
    return decorator
```

Git

```
git add --all
git commit -m "Calls : remove old unresolved"
git tag calls_rm_unresolved
```

# Mettre en place un mini-blog





# Généralité sur les tests automatisés

Pour montrer l'intérêt des tests automatisés, nous pouvons tout d'abord parler d'un cas d'école, celui du premier décollage du lanceur Ariane 5. Les lacunes de tests du lanceur ont eu pour effet la perte de 4 satellites (d'un montant de 370 millions de dollars).
Explications issues de Wikipédia :
"Tout tenait à une seule petite variable : celle allouée à l'accélération horizontale. En effet, l'accélération horizontale maximum produite par Ariane 4 donnait une valeur décimale d'environ 64. La valeur d'accélération horizontale de la fusée étant traitée dans un registre mémoire à 8 bits, cela donne en base binaire 28 = 256 valeurs disponibles, un nombre suffisant pour coder la valeur 64, qui donne en binaire 1000000 et ne nécessite que 7 bits. Mais Ariane 5 était bien plus puissante et brutale : son accélération pouvait atteindre la valeur 300, qui donne 100101100 en binaire et nécessite un registre à 9 bits. Ainsi, la variable codée sur 8 bits a connu un dépassement de capacité, puisque son emplacement mémoire n'était pas assez grand pour accepter une valeur aussi importante. Il aurait fallu la coder sur un bit de plus, donc 9 bits, ce qui aurait permis de stocker une valeur limite de 29-1 = 511, alors suffisante pour coder la valeur 300. De ce dépassement de capacité a résulté une valeur absurde dans la variable, ne correspondant pas à la réalité. Par effet domino, le logiciel décida de l'autodestruction de la fusée à partir de cette donnée erronée. "


## Les sept principes de tests de la norme ISTQB

ISTQB signifie International Software Testing Qualifications Board, ce qui signifie en français : comité international de qualification du test logiciel. Leurs préconisations et normes tendent à devenir le standard concernant les tests logiciels. L'ISTQB est une association à but non lucratif enregistrée en Belgique et qui propose des certifications et des formations à propos des tests informatiques. Les normes définies par l'ISTQB sont suivies scrupuleusement par les testeurs du monde entier. En France, Le CFTL (Comité français du test logiciel) propose des formations ISTQB ainsi que le passage d'examens ISTQB.

La norme ISTQB propose un ensemble de sept principes dans la mise en oeuvre des tests.

- **Principe 1** : ** les tests montrent la présence de défauts ** Les tests ne permettent pas de vérifier qu'il n'y a pas de défauts dans le logiciel. Les tests permettent cependant de prouver la présence de défauts. Ainsi, des tests valides correctement exécutés ne prouvent pas que le logiciel est exempt de défaut.
- **Principe 2** : **les tests exhaustifs sont impossibles** Il est inutile d'essayer de tester toutes les possibilités de scénarios et de jeux d'essai. Il faut analyser la façon de tester le logiciel de manière à découvrir le plus de non-conformités possible.
- **Principe 3** : **tester tôt** En effet, tester tôt permet de détecter plus rapidement des erreurs de code, mais également des erreurs de conception qui peuvent s'avérer lourdes à corriger lorsque le projet est à un stade avancé.
- **Principe 4** : **regroupement des défauts** L'effort de tests doit porter principalement sur les modules dont on estime qu'ils auront plus de défauts. L'idée est de définir les éléments prioritaires lors de la phase de conception.
- **Principe 5** : **paradoxe du pesticide** L'une des mauvaises habitudes des développeurs est de tester leur code avec le même jeu d'essai systématiquement. Pour la tenue des tests informatiques, cette habitude est également mauvaise. Les jeux d'essai doivent être révisés régulièrement de façon à détecter de nouvelles erreurs.
- **Principe 6** : **les tests dépendent du contexte** En effet, l'effort de tests doit être adapté au contexte et à la criticité des projets. Il est logique et économiquement normal qu'une voiture téléguidée pour enfant soit moins testée qu'une fusée de SpaceX.
- **Principe 7** : **l’illusion de l’absence d’erreurs** Bien qu'un projet soit testé à la perfection, il faut qu'il corresponde aux besoins des clients finaux. Les tests sont un indicateur de fiabilité et de sécurité, ils ne doivent pas devenir le seul indicateur de la réussite d'un projet.

## Niveaux des tests

L'ISTQB propose quatre niveaux de tests. Chaque niveau correspond à un type d'élément ciblé par le test. Chaque niveau de test peut accueillir différents types de tests.

### Tests de composants

Les tests de composants sont également appelés tests unitaires ou tests de modules. Ils ont pour but de rechercher les défaillances d'un programme dans ses fonctions, ses modules, ses objets et ses autres éléments. Les composants testés doivent être testables séparément sans nécessiter l'utilisation d'un autre composant (dont dépendrait le composant testé).
Pour tester des composants dépendant d'autres composants, il est possible d'utiliser des mocks, qui permettent de simuler les interactions entre des composants.

### Tests d'intégration

Les tests d'intégration ont pour but de tester l'interaction entre différentes parties d'un système. Les tests d'intégration n'ont pas pour but de tester le fonctionnement d'un composant.
Par exemple, dans le cas d'une application mobile servant à convertir des données. L'application utilise une API qui convertit des joules en kcal.
Un test d'intégration va vérifier que l'application (composant 1) récupère bien une valeur provenant de l'API (composant 2). La valeur obtenue importe peu, ce qui importe c'est qu'il n'y ait pas eu d'erreur dans l'intégration.
En revanche, un test d'intégration ne va pas vérifier si la valeur obtenue par l'API est correcte.

### Tests système

Les tests système ont pour but de tester le comportement du produit final (appelé système). Ce type de test doit être effectué dans un environnement le plus proche possible de l'environnement de production. Le périmètre de ces tests doit être clairement défini. Contrairement aux tests d'intégration, les tests système portent sur le comportement du produit final et peuvent donc inclure un nombre illimité de composants.

### Tests d'acceptation

Les tests d'acceptation ont pour but de vérifier que les fonctionnalités du produit final correspondent à ce qui est attendu. L'ISTQB explique que ce type de test permet par exemple :

– aux utilisateurs de vérifier l'ergonomie du produit (tests d'acceptation utilisateur),
– aux administrateurs système de vérifier le fonctionnement des migrations ou encore des sauvegardes (tests d'acceptation opérationnelle),
– de vérifier que les aspects réglementaires ou contractuels sont respectés (tests d'acceptations contractuelle et réglementaire).
Les tests d'acceptation sont généralement effectués par le client, un auditeur ou une autre partie prenante.

## Les types de tests

Dans son syllabus, l'ISTQB liste quatre types de tests. Les types de tests sont complémentaires aux niveaux des tests et peuvent se faire sur chaque niveau précédemment cité.

### Tests fonctionnels

Les tests fonctionnels ont pour but de tester le fonctionnement du système. Le but est de valider les spécifications d'une fonctionnalité. Par exemple, ce type de test peut permettre de vérifier que la mise en place de règles métier a bien été effectuée.
Ce type de test peut être utilisé à chaque niveau de test ; un test fonctionnel de composant pourra valider un comportement précis du composant vis-à-vis d'une spécification fonctionnelle. Un test fonctionnel système pourra par exemple valider le comportement d'un formulaire web en fonction des données entrées.

### Tests non fonctionnels

Les tests non fonctionnels ne cherchent pas à vérifier que le comportement du produit répond à ce qu'on attend de lui en termes de fonctionnalités. Il peut s'agir de tests de performance, de tests de sécurité ou encore de tests de montée en charge.
Ce type de test vise à garantir un certain niveau de qualité dans le produit final.

### Tests structurels

Le but de ces tests est de mesurer la couverture de code testé. La couverture du code est la proportion de code testé par rapport à l'ensemble du code du projet. Par exemple, si un projet a une couverture de code à 70 %, cela signifie que sur 100 lignes de code, les tests de composants (si on fait des tests structurels de composants) valident le comportement de 70 lignes de code. Pour le niveau intégration, la couverture peut correspondre au nombre d'interfaces testées sur le nombre d'interfaces totales du projet avec son environnement.
Le principal intérêt de mesurer cette couverture de code est qu'elle offre une bonne indication de la quantité de code testé. Certaines équipes ou certains projets libres peuvent tout à fait prévoir une couverture minimale de code pour tout nouvel incrément au projet.
Il faut cependant faire attention, la couverture de code est un indicateur qui ne reflète en rien la qualité des tests. Un projet testé à 100 % dont les tests auront été bâclés pourra être moins fiable qu'un projet correctement testé à 10 %.

### Tests de confirmation

Les tests de confirmation (également appelés tests de régression ou tests de non-régression) sont des tests effectués après que la correction d'une défaillance a été effectuée pour s'assurer qu'on pourra à nouveau détecter facilement cette défaillance.
Sur un scénario simple, cela donne la succession d'actions suivante :

– Une défaillance est détectée.
– Le développeur fait le correctif.
– Le testeur (qui peut être développeur) effectue le test de confirmation.

Lorsque le test de confirmation peut être automatisé (comme c'est le cas des tests logiciels de composants), une bonne pratique consiste à utiliser le TDD (Test-Driven Development). En effet, coder le test en premier permet de s'assurer qu'il échoue en situation initiale et qu'il n'échoue plus lorsque le correctif est terminé.







CONTINUER ICI







## Développement dirigé par les tests

Le développement dirigé par le test (TDD : Test Driven Development) est une pratique visant à coder les tests avant de développer la fonctionnalité. Le cycle de développement le plus commun dans les équipes de développeurs est le suivant :

– Étape 1 : développement d'une fonctionnalité, d'un module ou d'un correctif.
– Étape 2 : test manuel visant à vérifier l'étape 1.
– Étape 3 : si le test manuel de l'étape 2 échoue, alors on retourne à l'étape 1.

Cette façon de développer est assez intuitive, ce qui en fait la méthode privilégiée par les débutants. Dans ce cycle de développement, les étapes 1 et 2 sont effectuées de nombreuses fois et de façon manuelle. L'étape 1 qui consiste à coder n'est pas automatisable, mais l'étape 2 l'est. À partir du moment où le développeur connaît le ou les résultats attendus par son code, il peut facilement écrire les tests visant à vérifier le fonctionnement de son code.
Le TDD propose un nouveau cycle de développement :

– Étape 1 : le développeur rédige le test (ou les tests) décrivant une spécification désirée.
– Étape 2 : le développeur fait échouer le test.
– Étape 3 : le développeur code la fonctionnalité ou le module pour valider le test.
– Étape 4 : le développeur exécute le test.
– Étape 5 : si le test échoue, le développeur retourne à l'étape 3.
– Étape 6 : le développeur refactorise pour améliorer le code (le test doit bien évidemment passer après le refactoring).

L'avantage de ce nouveau cycle de développement est que l'étape de test est automatisée et non plus manuelle. Elle est donc à la fois plus rapide et plus fiable (parce qu'elle n'est plus soumise à l'interprétation humaine). Un autre avantage est que les tests développés en étape 1 vont devenir un réel actif du projet puisqu'ils permettront tout au long de la vie du projet de vérifier que les fonctionnalités sont toujours correctement implémentées. Il existe deux inconvénients principaux au TDD. Le premier est qu'il n'est pas évident pour un développeur débutant d'écrire les tests avant tout code, cela demande un effort intellectuel d'imaginer en amont le module à développer. L'autre inconvénient est que les tests créés devront être maintenus au fur et à mesure de la vie du projet. Malgré ces inconvénients, le TDD propose une méthode rigoureuse et ambitieuse de développement.
Le TDD prend encore plus de sens lorsqu'il s'agit de développer les tests de non-régression. Lorsqu'une défaillance est détectée dans le logiciel, une méthode vertueuse de correction est de coder le test reproduisant cette défaillance pour ensuite corriger le code menant à cette défaillance. Le test codé deviendra ainsi un test de confirmation et permettra tout au long de la vie du projet de détecter si la défaillance peut à nouveau avoir lieu.

# Tests automatisés Django

Django propose un système de tests automatisés assez complet, permettant notamment de simuler un client.

Pour ajouter des tests à l'applications users, il faut ajouter le contenu suivant au fichier `users/tests.py` : 

```
from django.test import TestCase, Client

from .models import UserProfile

# Exécution
# python manage.py test 

class UserTestCase(TestCase):

    def client_create_connect_admin(self, c):
        user = UserProfile.objects.create_user(
            username="admin",
            email="admin@admin.com",
            password="admin",
            is_superuser=True,
            is_staff=True,
            )
        c.login(username='admin', password='admin')
        return c


    def test_no_error(self):

        self.assertEqual("Test", 'Test')

    def test_hello(self):

        c = Client()

        response = c.get('/users/hello/')
        
        self.assertEqual(response.status_code, 200)
        self.assertTrue("Hello World!" in str(response.content))

    def test_admin(self):

        c = Client()

        response = c.get('/admin/')

        self.assertEqual(response.status_code, 302)

        success = c.login(username='admin', password='admin')

        # Normalement, on ne teste pas les responsabilités externes
        self.assertEqual(success, False)

        user = UserProfile.objects.create_user(
            username="admin",
            email="admin@admin.com",
            password="admin",
            is_superuser=True,
            is_staff=True,
            )
        user.save()

        success = c.login(username='admin', password='admin')

        # Normalement, on ne teste pas les responsabilités externes.

        self.assertEqual(success, True)

        response = c.get('/admin/')

        self.assertEqual(response.status_code, 200)

    def test_attribution(self):
        c = Client()
        response = c.get('/users/role-attribution/')
        self.assertEqual(response.status_code, 302)

        UserProfile.objects.create_user(
            username="teammember_user",
            email="dkdie@admin.com",
            password="teammember_user",
            ).save()
        c.login(username='teammember_user', password='teammember_user')

        response = c.get('/users/role-attribution/')
        self.assertEqual(response.status_code, 302)

        client = self.client_create_connect_admin(c)
        response = c.get('/users/role-attribution/')
        self.assertEqual(response.status_code, 200)
        self.assertTrue("teammember_user" in str(response.content))

```

Dans ce fichier nous testons : 

- Que deux même chaines donnent le même résultat. (Le but est de montrer la syntaxe).
- Que l'affichage de la page users/hello renvoie un code HTTP 200
- Que cette page renvoie bien le texte Hello World!
- On vérifie que la page /admin redirige un utilisateur non connecté
- On vérifie que la connexion avec le user admin échoue (ça permet de vérifier qu'une base de données de tests est créée à la volée)
- On vérifie que la création du superuser fonctionne.
- On vérifie que la même URL retourne un code 200 HTTP qui nous prouve l'accès de l'utilisateur admin au module d'administration.
- On vérifie que la page d'attribution de rôle n'est pas accessible à un utilisateur non connecté.
- On vérifie que la page d'attribution de rôle n'est pas accessible à un utilisateur connecté standard.
- On vérifie que la page d'attribution de rôle est accessible à un superuser connecté.
- On vérifie que la page d'attribution affiche le username de notre utilisateur créé.






Django summernote



# Evaluation : 


L'évaluation portera sur l'utilisation des fonctionnalités de Django : 
- Utilisation des CBV, ModelForm ou formulaires Django
- Utilisation des models, urls
- Qualité de conception et développement
- La lisibilité du code compte. Un code lisible est un code maintenable.
- Le front-end compte pour très peu dans l'évaluation, concentrez-vous sur le back-end et l'utilisation de Django.
- Il est important de bien peaufiner ses models. Ils sont la base du projet.


Créer un projet publié sur Github : 

Ce projet permettra de monitorer des URLs.
Les objectifs du projets sont : 
- De pouvoir renseigner des URLs et leur responsabilité métier (qu'une erreur n'envoie pas juste l'URL www.google.com/admin mais également "Partie Admin Google")
- De pouvoir logguer toutes les vérifications (ayant entrainées une erreur ou non)
- De définir des critères d'erreur (Code HTTP, présence de texte sur la page, temps de réponse, validation du certificat SSL, délai en j avant expiration, etc.). Vous n'êtes pas obligé de tous les rajouter. Ou alors vous partez avec 1 ou 2 critères et vous en ajoutez au fur et à mesures si vous voulez.
- L'envoi d'un mail pour les sites ayant été en erreur avec des infos sur les erreurs si possible.
- Créer un module d'administration complet.


Toutes les fonctionnalités ne sont pas demandées. Vous pouvez d'ailleurs imaginer d'autres fonctionnalités. Le but est d'expérimenter Django. Ajouter les champs qui vous semblent utiles.
Essayer de garder vos commits cohérents.
Il faudra pusher le dépôt sur GitHub en public et m'envoyer l'URL par email sur samuel@dauzon.com.
Il faudra aussi pusher votre fichier de settings (soit en l'ajoutant en example, soit en modifiant votre fichier .gitignore)





        


